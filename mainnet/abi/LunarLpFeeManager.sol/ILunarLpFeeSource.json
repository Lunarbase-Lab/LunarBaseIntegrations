{"abi":[{"type":"function","name":"balanceOf","inputs":[{"name":"account","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"collectFees","inputs":[{"name":"to","type":"address","internalType":"address"},{"name":"amount0","type":"uint128","internalType":"uint128"},{"name":"amount1","type":"uint128","internalType":"uint128"}],"outputs":[{"name":"","type":"uint128","internalType":"uint128"},{"name":"","type":"uint128","internalType":"uint128"}],"stateMutability":"nonpayable"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"balanceOf(address)":"70a08231","collectFees(address,uint128,uint128)":"755f2e45"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amount0\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"amount1\",\"type\":\"uint128\"}],\"name\":\"collectFees\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"balanceOf(address)\":{\"params\":{\"account\":\"Address to query.\"},\"returns\":{\"_0\":\"balance LP token balance.\"}},\"collectFees(address,uint128,uint128)\":{\"params\":{\"amount0\":\"Amount of token0 fees to pay.\",\"amount1\":\"Amount of token1 fees to pay.\",\"to\":\"Recipient address.\"},\"returns\":{\"_0\":\"paid0 Actual amount of token0 fees transferred.\",\"_1\":\"paid1 Actual amount of token1 fees transferred.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"balanceOf(address)\":{\"notice\":\"Returns the LP token balance for the account.\"},\"collectFees(address,uint128,uint128)\":{\"notice\":\"Transfers accrued fee buckets to the recipient.\"}},\"notice\":\"Minimal pool interface used by the LP fee manager to pull fees.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/contracts/LunarFees/LunarLpFeeManager.sol\":\"ILunarLpFeeSource\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[\":@ensdomains/=lib/v4-core/node_modules/@ensdomains/\",\":@lunar/=src/\",\":@openzeppelin/=lib/openzeppelin-contracts/\",\":@uniswap/v4-core/=lib/v4-core/\",\":ds-test/=lib/v4-core/lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-gas-snapshot/=lib/v4-periphery/lib/permit2/lib/forge-gas-snapshot/src/\",\":forge-std/=lib/forge-std/src/\",\":halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/\",\":hardhat/=lib/v4-core/node_modules/hardhat/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":permit2/=lib/v4-periphery/lib/permit2/\",\":prb-math/=lib/prb-math/src/\",\":solady/=lib/solady/src/\",\":solmate/=lib/v4-core/lib/solmate/\",\":v4-core/=lib/v4-core/src/\",\":v4-periphery/=lib/v4-periphery/\"],\"viaIR\":true},\"sources\":{\"lib/openzeppelin-contracts/contracts/utils/Panic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Helper library for emitting standardized panic codes.\\n *\\n * ```solidity\\n * contract Example {\\n *      using Panic for uint256;\\n *\\n *      // Use any of the declared internal constants\\n *      function foo() { Panic.GENERIC.panic(); }\\n *\\n *      // Alternatively\\n *      function foo() { Panic.panic(Panic.GENERIC); }\\n * }\\n * ```\\n *\\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\\n *\\n * _Available since v5.1._\\n */\\n// slither-disable-next-line unused-state\\nlibrary Panic {\\n    /// @dev generic / unspecified error\\n    uint256 internal constant GENERIC = 0x00;\\n    /// @dev used by the assert() builtin\\n    uint256 internal constant ASSERT = 0x01;\\n    /// @dev arithmetic underflow or overflow\\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\\n    /// @dev division or modulo by zero\\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\\n    /// @dev enum conversion error\\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\\n    /// @dev invalid encoding in storage\\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\\n    /// @dev empty array pop\\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\\n    /// @dev array out of bounds access\\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\\n    /// @dev resource error (too large allocation or too large array)\\n    uint256 internal constant RESOURCE_ERROR = 0x41;\\n    /// @dev calling invalid internal function\\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\\n\\n    /// @dev Reverts with a panic code. Recommended to use with\\n    /// the internal constants with predefined codes.\\n    function panic(uint256 code) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, 0x4e487b71)\\n            mstore(0x20, code)\\n            revert(0x1c, 0x24)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf7fe324703a64fc51702311dc51562d5cb1497734f074e4f483bfb6717572d7a\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {StorageSlot} from \\\"./StorageSlot.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\\n * consider using {ReentrancyGuardTransient} instead.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * IMPORTANT: Deprecated. This storage-based reentrancy guard will be removed and replaced\\n * by the {ReentrancyGuardTransient} variant in v6.0.\\n *\\n * @custom:stateless\\n */\\nabstract contract ReentrancyGuard {\\n    using StorageSlot for bytes32;\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.ReentrancyGuard\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant REENTRANCY_GUARD_STORAGE =\\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\\n\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _reentrancyGuardStorageSlot().getUint256Slot().value = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    /**\\n     * @dev A `view` only version of {nonReentrant}. Use to block view functions\\n     * from being called, preventing reading from inconsistent contract state.\\n     *\\n     * CAUTION: This is a \\\"view\\\" modifier and does not change the reentrancy\\n     * status. Use it only on view functions. For payable or non-payable functions,\\n     * use the standard {nonReentrant} modifier instead.\\n     */\\n    modifier nonReentrantView() {\\n        _nonReentrantBeforeView();\\n        _;\\n    }\\n\\n    function _nonReentrantBeforeView() private view {\\n        if (_reentrancyGuardEntered()) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        _nonReentrantBeforeView();\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _reentrancyGuardStorageSlot().getUint256Slot().value = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _reentrancyGuardStorageSlot().getUint256Slot().value = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _reentrancyGuardStorageSlot().getUint256Slot().value == ENTERED;\\n    }\\n\\n    function _reentrancyGuardStorageSlot() internal pure virtual returns (bytes32) {\\n        return REENTRANCY_GUARD_STORAGE;\\n    }\\n}\\n\",\"keccak256\":\"0xa516cbf1c7d15d3517c2d668601ce016c54395bf5171918a14e2686977465f53\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC-1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * TIP: Consider using this library along with {SlotDerivation}.\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct Int256Slot {\\n        int256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\\n     */\\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcf74f855663ce2ae00ed8352666b7935f6cddea2932fdf2c3ecd30a9b1cd0e97\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Panic} from \\\"../Panic.sol\\\";\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Return the 512-bit addition of two uint256.\\n     *\\n     * The result is stored in two 256 variables such that sum = high * 2\\u00b2\\u2075\\u2076 + low.\\n     */\\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\\n        assembly (\\\"memory-safe\\\") {\\n            low := add(a, b)\\n            high := lt(low, a)\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the 512-bit multiplication of two uint256.\\n     *\\n     * The result is stored in two 256 variables such that product = high * 2\\u00b2\\u2075\\u2076 + low.\\n     */\\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2\\u00b2\\u2075\\u2076 and mod 2\\u00b2\\u2075\\u2076 - 1, then use\\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = high * 2\\u00b2\\u2075\\u2076 + low.\\n        assembly (\\\"memory-safe\\\") {\\n            let mm := mulmod(a, b, not(0))\\n            low := mul(a, b)\\n            high := sub(sub(mm, low), lt(mm, low))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a + b;\\n            success = c >= a;\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a - b;\\n            success = c <= a;\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a * b;\\n            assembly (\\\"memory-safe\\\") {\\n                // Only true when the multiplication doesn't overflow\\n                // (c / a == b) || (a == 0)\\n                success := or(eq(div(c, a), b), iszero(a))\\n            }\\n            // equivalent to: success ? c : 0\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            success = b > 0;\\n            assembly (\\\"memory-safe\\\") {\\n                // The `DIV` opcode returns zero when the denominator is 0.\\n                result := div(a, b)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            success = b > 0;\\n            assembly (\\\"memory-safe\\\") {\\n                // The `MOD` opcode returns zero when the denominator is 0.\\n                result := mod(a, b)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating addition, bounds to `2\\u00b2\\u2075\\u2076 - 1` instead of overflowing.\\n     */\\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (bool success, uint256 result) = tryAdd(a, b);\\n        return ternary(success, result, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\\n     */\\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (, uint256 result) = trySub(a, b);\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating multiplication, bounds to `2\\u00b2\\u2075\\u2076 - 1` instead of overflowing.\\n     */\\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (bool success, uint256 result) = tryMul(a, b);\\n        return ternary(success, result, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev Branchless ternary evaluation for `condition ? a : b`. Gas costs are constant.\\n     *\\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\\n     * However, the compiler may optimize Solidity ternary operations (i.e. `condition ? a : b`) to only compute\\n     * one branch when needed, making this function more expensive.\\n     */\\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            // branchless ternary works because:\\n            // b ^ (a ^ b) == a\\n            // b ^ 0 == b\\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return ternary(a > b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return ternary(a < b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            // (a + b) / 2 can overflow.\\n            return (a & b) + (a ^ b) / 2;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n\\n        // The following calculation ensures accurate ceiling division without overflow.\\n        // Since a is non-zero, (a - 1) / b will not overflow.\\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\\n        // when a = type(uint256).max and b = 1.\\n        unchecked {\\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     *\\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            (uint256 high, uint256 low) = mul512(x, y);\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (high == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return low / denominator;\\n            }\\n\\n            // Make sure the result is less than 2\\u00b2\\u2075\\u2076. Also prevents denominator == 0.\\n            if (denominator <= high) {\\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [high low].\\n            uint256 remainder;\\n            assembly (\\\"memory-safe\\\") {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                high := sub(high, gt(remainder, low))\\n                low := sub(low, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly (\\\"memory-safe\\\") {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [high low] by twos.\\n                low := div(low, twos)\\n\\n                // Flip twos such that it is 2\\u00b2\\u2075\\u2076 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from high into low.\\n            low |= high * twos;\\n\\n            // Invert denominator mod 2\\u00b2\\u2075\\u2076. Now that denominator is an odd number, it has an inverse modulo 2\\u00b2\\u2075\\u2076 such\\n            // that denominator * inv \\u2261 1 mod 2\\u00b2\\u2075\\u2076. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv \\u2261 1 mod 2\\u2074.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u2078\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u00b9\\u2076\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u00b3\\u00b2\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u2076\\u2074\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u00b9\\u00b2\\u2078\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\\u00b2\\u2075\\u2076\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2\\u00b2\\u2075\\u2076. Since the preconditions guarantee that the outcome is\\n            // less than 2\\u00b2\\u2075\\u2076, this is the final result. We don't need to compute the high bits of the result and high\\n            // is no longer required.\\n            result = low * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\\n    }\\n\\n    /**\\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\\n     */\\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\\n        unchecked {\\n            (uint256 high, uint256 low) = mul512(x, y);\\n            if (high >= 1 << n) {\\n                Panic.panic(Panic.UNDER_OVERFLOW);\\n            }\\n            return (high << (256 - n)) | (low >> n);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\\n     */\\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\\n    }\\n\\n    /**\\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\\n     *\\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\\n     *\\n     * If the input value is not inversible, 0 is returned.\\n     *\\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\\n     */\\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\\n        unchecked {\\n            if (n == 0) return 0;\\n\\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\\n            // ax + ny = 1\\n            // ax = 1 + (-y)n\\n            // ax \\u2261 1 (mod n) # x is the inverse of a modulo n\\n\\n            // If the remainder is 0 the gcd is n right away.\\n            uint256 remainder = a % n;\\n            uint256 gcd = n;\\n\\n            // Therefore the initial coefficients are:\\n            // ax + ny = gcd(a, n) = n\\n            // 0a + 1n = n\\n            int256 x = 0;\\n            int256 y = 1;\\n\\n            while (remainder != 0) {\\n                uint256 quotient = gcd / remainder;\\n\\n                (gcd, remainder) = (\\n                    // The old remainder is the next gcd to try.\\n                    remainder,\\n                    // Compute the next remainder.\\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\\n                    // where gcd is at most n (capped to type(uint256).max)\\n                    gcd - remainder * quotient\\n                );\\n\\n                (x, y) = (\\n                    // Increment the coefficient of a.\\n                    y,\\n                    // Decrement the coefficient of n.\\n                    // Can overflow, but the result is casted to uint256 so that the\\n                    // next value of y is \\\"wrapped around\\\" to a value between 0 and n - 1.\\n                    x - y * int256(quotient)\\n                );\\n            }\\n\\n            if (gcd != 1) return 0; // No inverse exists.\\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\\n        }\\n    }\\n\\n    /**\\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\\n     *\\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\\n     * prime, then `a**(p-1) \\u2261 1 mod p`. As a consequence, we have `a * a**(p-2) \\u2261 1 mod p`, which means that\\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\\n     *\\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\\n     */\\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\\n        unchecked {\\n            return Math.modExp(a, p - 2, p);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\\n     *\\n     * Requirements:\\n     * - modulus can't be zero\\n     * - underlying staticcall to precompile must succeed\\n     *\\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\\n     * interpreted as 0.\\n     */\\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\\n        (bool success, uint256 result) = tryModExp(b, e, m);\\n        if (!success) {\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\\n     * to operate modulo 0 or if the underlying precompile reverted.\\n     *\\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\\n     * of a revert, but the result may be incorrectly interpreted as 0.\\n     */\\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\\n        if (m == 0) return (false, 0);\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40)\\n            // | Offset    | Content    | Content (Hex)                                                      |\\n            // |-----------|------------|--------------------------------------------------------------------|\\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\\n            mstore(ptr, 0x20)\\n            mstore(add(ptr, 0x20), 0x20)\\n            mstore(add(ptr, 0x40), 0x20)\\n            mstore(add(ptr, 0x60), b)\\n            mstore(add(ptr, 0x80), e)\\n            mstore(add(ptr, 0xa0), m)\\n\\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\\n            // so we can use the memory scratch space located at offset 0.\\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /**\\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\\n     */\\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\\n        (bool success, bytes memory result) = tryModExp(b, e, m);\\n        if (!success) {\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\\n     */\\n    function tryModExp(\\n        bytes memory b,\\n        bytes memory e,\\n        bytes memory m\\n    ) internal view returns (bool success, bytes memory result) {\\n        if (_zeroBytes(m)) return (false, new bytes(0));\\n\\n        uint256 mLen = m.length;\\n\\n        // Encode call args in result and move the free memory pointer\\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\\n\\n        assembly (\\\"memory-safe\\\") {\\n            let dataPtr := add(result, 0x20)\\n            // Write result on top of args to avoid allocating extra memory.\\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\\n            // Overwrite the length.\\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\\n            mstore(result, mLen)\\n            // Set the memory pointer after the returned data.\\n            mstore(0x40, add(dataPtr, mLen))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether the provided byte array is zero.\\n     */\\n    function _zeroBytes(bytes memory buffer) private pure returns (bool) {\\n        uint256 chunk;\\n        for (uint256 i = 0; i < buffer.length; i += 0x20) {\\n            // See _unsafeReadBytesOffset from utils/Bytes.sol\\n            assembly (\\\"memory-safe\\\") {\\n                chunk := mload(add(add(buffer, 0x20), i))\\n            }\\n            if (chunk >> (8 * saturatingSub(i + 0x20, buffer.length)) != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\\n     * using integer operations.\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        unchecked {\\n            // Take care of easy edge cases when a == 0 or a == 1\\n            if (a <= 1) {\\n                return a;\\n            }\\n\\n            // In this function, we use Newton's method to get a root of `f(x) := x\\u00b2 - a`. It involves building a\\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\\n            // the current value as `\\u03b5_n = | x_n - sqrt(a) |`.\\n            //\\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\\n            // of the target. (i.e. `2**(e-1) \\u2264 sqrt(a) < 2**e`). We know that `e \\u2264 128` because `(2\\u00b9\\u00b2\\u2078)\\u00b2 = 2\\u00b2\\u2075\\u2076` is\\n            // bigger than any uint256.\\n            //\\n            // By noticing that\\n            // `2**(e-1) \\u2264 sqrt(a) < 2**e \\u2192 (2**(e-1))\\u00b2 \\u2264 a < (2**e)\\u00b2 \\u2192 2**(2*e-2) \\u2264 a < 2**(2*e)`\\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\\n            // to the msb function.\\n            uint256 aa = a;\\n            uint256 xn = 1;\\n\\n            if (aa >= (1 << 128)) {\\n                aa >>= 128;\\n                xn <<= 64;\\n            }\\n            if (aa >= (1 << 64)) {\\n                aa >>= 64;\\n                xn <<= 32;\\n            }\\n            if (aa >= (1 << 32)) {\\n                aa >>= 32;\\n                xn <<= 16;\\n            }\\n            if (aa >= (1 << 16)) {\\n                aa >>= 16;\\n                xn <<= 8;\\n            }\\n            if (aa >= (1 << 8)) {\\n                aa >>= 8;\\n                xn <<= 4;\\n            }\\n            if (aa >= (1 << 4)) {\\n                aa >>= 4;\\n                xn <<= 2;\\n            }\\n            if (aa >= (1 << 2)) {\\n                xn <<= 1;\\n            }\\n\\n            // We now have x_n such that `x_n = 2**(e-1) \\u2264 sqrt(a) < 2**e = 2 * x_n`. This implies \\u03b5_n \\u2264 2**(e-1).\\n            //\\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to \\u03b5_n \\u2264 2**(e-2).\\n            // This is going to be our x_0 (and \\u03b5_0)\\n            xn = (3 * xn) >> 1; // \\u03b5_0 := | x_0 - sqrt(a) | \\u2264 2**(e-2)\\n\\n            // From here, Newton's method give us:\\n            // x_{n+1} = (x_n + a / x_n) / 2\\n            //\\n            // One should note that:\\n            // x_{n+1}\\u00b2 - a = ((x_n + a / x_n) / 2)\\u00b2 - a\\n            //              = ((x_n\\u00b2 + a) / (2 * x_n))\\u00b2 - a\\n            //              = (x_n\\u2074 + 2 * a * x_n\\u00b2 + a\\u00b2) / (4 * x_n\\u00b2) - a\\n            //              = (x_n\\u2074 + 2 * a * x_n\\u00b2 + a\\u00b2 - 4 * a * x_n\\u00b2) / (4 * x_n\\u00b2)\\n            //              = (x_n\\u2074 - 2 * a * x_n\\u00b2 + a\\u00b2) / (4 * x_n\\u00b2)\\n            //              = (x_n\\u00b2 - a)\\u00b2 / (2 * x_n)\\u00b2\\n            //              = ((x_n\\u00b2 - a) / (2 * x_n))\\u00b2\\n            //              \\u2265 0\\n            // Which proves that for all n \\u2265 1, sqrt(a) \\u2264 x_n\\n            //\\n            // This gives us the proof of quadratic convergence of the sequence:\\n            // \\u03b5_{n+1} = | x_{n+1} - sqrt(a) |\\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\\n            //         = | (x_n\\u00b2 + a - 2*x_n*sqrt(a)) / (2 * x_n) |\\n            //         = | (x_n - sqrt(a))\\u00b2 / (2 * x_n) |\\n            //         = | \\u03b5_n\\u00b2 / (2 * x_n) |\\n            //         = \\u03b5_n\\u00b2 / | (2 * x_n) |\\n            //\\n            // For the first iteration, we have a special case where x_0 is known:\\n            // \\u03b5_1 = \\u03b5_0\\u00b2 / | (2 * x_0) |\\n            //     \\u2264 (2**(e-2))\\u00b2 / (2 * (2**(e-1) + 2**(e-2)))\\n            //     \\u2264 2**(2*e-4) / (3 * 2**(e-1))\\n            //     \\u2264 2**(e-3) / 3\\n            //     \\u2264 2**(e-3-log2(3))\\n            //     \\u2264 2**(e-4.5)\\n            //\\n            // For the following iterations, we use the fact that, 2**(e-1) \\u2264 sqrt(a) \\u2264 x_n:\\n            // \\u03b5_{n+1} = \\u03b5_n\\u00b2 / | (2 * x_n) |\\n            //         \\u2264 (2**(e-k))\\u00b2 / (2 * 2**(e-1))\\n            //         \\u2264 2**(2*e-2*k) / 2**e\\n            //         \\u2264 2**(e-2*k)\\n            xn = (xn + a / xn) >> 1; // \\u03b5_1 := | x_1 - sqrt(a) | \\u2264 2**(e-4.5)  -- special case, see above\\n            xn = (xn + a / xn) >> 1; // \\u03b5_2 := | x_2 - sqrt(a) | \\u2264 2**(e-9)    -- general case with k = 4.5\\n            xn = (xn + a / xn) >> 1; // \\u03b5_3 := | x_3 - sqrt(a) | \\u2264 2**(e-18)   -- general case with k = 9\\n            xn = (xn + a / xn) >> 1; // \\u03b5_4 := | x_4 - sqrt(a) | \\u2264 2**(e-36)   -- general case with k = 18\\n            xn = (xn + a / xn) >> 1; // \\u03b5_5 := | x_5 - sqrt(a) | \\u2264 2**(e-72)   -- general case with k = 36\\n            xn = (xn + a / xn) >> 1; // \\u03b5_6 := | x_6 - sqrt(a) | \\u2264 2**(e-144)  -- general case with k = 72\\n\\n            // Because e \\u2264 128 (as discussed during the first estimation phase), we know have reached a precision\\n            // \\u03b5_6 \\u2264 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\\n            // sqrt(a) or sqrt(a) + 1.\\n            return xn - SafeCast.toUint(xn > a / xn);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        // If value has upper 128 bits set, log2 result is at least 128\\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\\n        // If upper 64 bits of 128-bit half set, add 64 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\\n        // If upper 32 bits of 64-bit half set, add 32 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\\n        // If upper 16 bits of 32-bit half set, add 16 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\\n        // If upper 8 bits of 16-bit half set, add 8 to result\\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\\n        // If upper 4 bits of 8-bit half set, add 4 to result\\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\\n\\n        // Shifts value right by the current result and use it as an index into this lookup table:\\n        //\\n        // | x (4 bits) |  index  | table[index] = MSB position |\\n        // |------------|---------|-----------------------------|\\n        // |    0000    |    0    |        table[0] = 0         |\\n        // |    0001    |    1    |        table[1] = 0         |\\n        // |    0010    |    2    |        table[2] = 1         |\\n        // |    0011    |    3    |        table[3] = 1         |\\n        // |    0100    |    4    |        table[4] = 2         |\\n        // |    0101    |    5    |        table[5] = 2         |\\n        // |    0110    |    6    |        table[6] = 2         |\\n        // |    0111    |    7    |        table[7] = 2         |\\n        // |    1000    |    8    |        table[8] = 3         |\\n        // |    1001    |    9    |        table[9] = 3         |\\n        // |    1010    |   10    |        table[10] = 3        |\\n        // |    1011    |   11    |        table[11] = 3        |\\n        // |    1100    |   12    |        table[12] = 3        |\\n        // |    1101    |   13    |        table[13] = 3        |\\n        // |    1110    |   14    |        table[14] = 3        |\\n        // |    1111    |   15    |        table[15] = 3        |\\n        //\\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\\n        assembly (\\\"memory-safe\\\") {\\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 x) internal pure returns (uint256 r) {\\n        // If value has upper 128 bits set, log2 result is at least 128\\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\\n        // If upper 64 bits of 128-bit half set, add 64 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\\n        // If upper 32 bits of 64-bit half set, add 32 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\\n        // If upper 16 bits of 32-bit half set, add 16 to result\\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n\\n    /**\\n     * @dev Counts the number of leading zero bits in a uint256.\\n     */\\n    function clz(uint256 x) internal pure returns (uint256) {\\n        return ternary(x == 0, 256, 255 - log2(x));\\n    }\\n}\\n\",\"keccak256\":\"0xc272e2d5e7144ec7564f6aa231ed4bc423497997f99f408a235ff2016d25e785\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n\\n    /**\\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\\n     */\\n    function toUint(bool b) internal pure returns (uint256 u) {\\n        assembly (\\\"memory-safe\\\") {\\n            u := iszero(iszero(b))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x195533c86d0ef72bcc06456a4f66a9b941f38eb403739b00f21fd7c1abd1ae54\",\"license\":\"MIT\"},\"src/contracts/LunarFees/LunarLpFeeManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n//\\n//                \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n//           \\u2588\\u2588\\u2588\\u2588                 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588      \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n//         \\u2588\\u2588\\u2588\\u2588      \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588       \\u2588\\u2588\\u2588\\u2588\\u2588    \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n//       \\u2588\\u2588\\u2588\\u2588     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                  \\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588\\u2588\\u2588     \\u2588\\u2588\\u2588\\u2588\\u2588        \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n//      \\u2588\\u2588\\u2588     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                    \\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588     \\u2588\\u2588   \\u2588\\u2588\\u2588\\u2588   \\u2588   \\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588\\u2588\\u2588\\n//     \\u2588\\u2588\\u2588     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                     \\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588   \\u2588  \\u2588   \\u2588\\u2588\\u2588\\u2588   \\u2588   \\u2588\\u2588\\u2588\\u2588        \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n//     \\u2588\\u2588\\u2588    \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                     \\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588    \\u2588\\u2588          \\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588\\u2588\\u2588\\n//     \\u2588\\u2588    \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                      \\u2588\\u2588\\u2588\\u2588       \\u2588\\u2588\\u2588\\u2588\\u2588     \\u2588\\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588    \\u2588\\u2588   \\u2588\\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588   \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588\\n//     \\u2588\\u2588    \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                      \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n//     \\u2588\\u2588    \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n//     \\u2588\\u2588     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n//     \\u2588\\u2588\\u2588     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                               \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588       \\u2588\\u2588\\u2588      \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588    \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n//      \\u2588\\u2588\\u2588      \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588                            \\u2588\\u2588\\u2588  \\u2588\\u2588     \\u2588\\u2588\\u2588\\u2588\\u2588    \\u2588\\u2588         \\u2588\\u2588\\n//       \\u2588\\u2588\\u2588\\u2588     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2588                    \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588     \\u2588\\u2588 \\u2588\\u2588     \\u2588\\u2588\\u2588\\u2588\\u2588     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n//         \\u2588\\u2588\\u2588        \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588       \\u2588\\u2588\\u2588\\u2588                   \\u2588\\u2588\\u2588  \\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588        \\u2588\\u2588\\u2588   \\u2588\\u2588\\n//           \\u2588\\u2588\\u2588\\u2588                  \\u2588\\u2588\\u2588\\u2588                     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588   \\u2588\\u2588\\u2588  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588    \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n//                \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n//\\npragma solidity ^0.8.21;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport {ILunarLpFeeManager} from \\\"@lunar/interfaces/ILunarLpFeeManager.sol\\\";\\nimport {LunarLpFeeManager__NotPool, LunarLpFeeManager__ZeroAddress, LunarLpFeeManager__NothingToClaim, LunarLpFeeManager__AmountTooLarge} from \\\"@lunar/errors/Errors_LunarLpFeeManager.sol\\\";\\n\\n/// @notice Minimal pool interface used by the LP fee manager to pull fees.\\ninterface ILunarLpFeeSource {\\n    /// @notice Returns the LP token balance for the account.\\n    /// @param account Address to query.\\n    /// @return balance LP token balance.\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Transfers accrued fee buckets to the recipient.\\n    /// @param to Recipient address.\\n    /// @param amount0 Amount of token0 fees to pay.\\n    /// @param amount1 Amount of token1 fees to pay.\\n    /// @return paid0 Actual amount of token0 fees transferred.\\n    /// @return paid1 Actual amount of token1 fees transferred.\\n    function collectFees(\\n        address to,\\n        uint128 amount0,\\n        uint128 amount1\\n    ) external returns (uint128, uint128);\\n}\\n\\n/// @notice Centralized LP fee accounting manager shared by all pools.\\ncontract LunarLpFeeManager is ILunarLpFeeManager, ReentrancyGuard {\\n    uint256 public constant ACC_SCALE = 1e18;\\n\\n    struct PoolState {\\n        uint256 accFee0PerShare;\\n        uint256 accFee1PerShare;\\n    }\\n\\n    struct AccountState {\\n        uint256 fee0Debt;\\n        uint256 fee1Debt;\\n        uint256 fee0Accrued;\\n        uint256 fee1Accrued;\\n    }\\n\\n    mapping(address => PoolState) public poolState;\\n    mapping(address => mapping(address => AccountState)) public accountState;\\n\\n    event FeesAccrued(address indexed pool, uint256 fee0, uint256 fee1);\\n    event AccountUpdated(\\n        address indexed pool,\\n        address indexed account,\\n        uint256 oldBalance,\\n        uint256 newBalance\\n    );\\n    event FeesClaimed(\\n        address indexed pool,\\n        address indexed account,\\n        address indexed to,\\n        uint256 fee0,\\n        uint256 fee1\\n    );\\n\\n    /// @notice Records new fees accrued by a pool and updates per-share accumulators.\\n    /// @dev Only callable by the pool that accrued the fees.\\n    /// @param pool Pool address emitting the fees.\\n    /// @param fee0 Token0 fee amount accrued in the pool.\\n    /// @param fee1 Token1 fee amount accrued in the pool.\\n    /// @param lpSupply Current LP supply of the pool.\\n    function onFeesAccrued(\\n        address pool,\\n        uint256 fee0,\\n        uint256 fee1,\\n        uint256 lpSupply\\n    ) external override {\\n        if (msg.sender != pool) revert LunarLpFeeManager__NotPool();\\n        if (lpSupply == 0) return;\\n        PoolState storage ps = poolState[pool];\\n        if (fee0 > 0)\\n            ps.accFee0PerShare += Math.mulDiv(fee0, ACC_SCALE, lpSupply);\\n        if (fee1 > 0)\\n            ps.accFee1PerShare += Math.mulDiv(fee1, ACC_SCALE, lpSupply);\\n        if (fee0 > 0 || fee1 > 0) emit FeesAccrued(pool, fee0, fee1);\\n    }\\n\\n    /// @notice Updates fee debts when an LP balance changes.\\n    /// @dev Only callable by the pool whose balances changed.\\n    /// @param pool Pool address.\\n    /// @param account LP account whose balance changed.\\n    /// @param oldBalance Previous LP balance.\\n    /// @param newBalance New LP balance.\\n    function onBalanceChange(\\n        address pool,\\n        address account,\\n        uint256 oldBalance,\\n        uint256 newBalance\\n    ) external override {\\n        if (msg.sender != pool) revert LunarLpFeeManager__NotPool();\\n        _updateAccount(pool, account, oldBalance, newBalance);\\n    }\\n\\n    /// @notice Claims accrued fees for the caller from a pool.\\n    /// @param pool Pool address.\\n    /// @param to Recipient of the fee payout.\\n    /// @return fee0 Amount of token0 fees paid.\\n    /// @return fee1 Amount of token1 fees paid.\\n    function claim(\\n        address pool,\\n        address to\\n    ) external override nonReentrant returns (uint256 fee0, uint256 fee1) {\\n        if (to == address(0)) revert LunarLpFeeManager__ZeroAddress();\\n        ILunarLpFeeSource source = ILunarLpFeeSource(pool);\\n        uint256 balance = source.balanceOf(msg.sender);\\n        _updateAccount(pool, msg.sender, balance, balance);\\n\\n        AccountState storage st = accountState[pool][msg.sender];\\n        fee0 = st.fee0Accrued;\\n        fee1 = st.fee1Accrued;\\n        if (fee0 == 0 && fee1 == 0) revert LunarLpFeeManager__NothingToClaim();\\n        if (fee0 > type(uint128).max || fee1 > type(uint128).max) {\\n            revert LunarLpFeeManager__AmountTooLarge();\\n        }\\n        st.fee0Accrued = 0;\\n        st.fee1Accrued = 0;\\n\\n        (uint128 paid0, uint128 paid1) = source.collectFees(\\n            to,\\n            uint128(fee0),\\n            uint128(fee1)\\n        );\\n        fee0 = paid0;\\n        fee1 = paid1;\\n        emit FeesClaimed(pool, msg.sender, to, fee0, fee1);\\n    }\\n\\n    /// @notice Previews the claimable fees for an account without modifying state.\\n    /// @param pool Pool address.\\n    /// @param account Account to preview.\\n    /// @return fee0 Claimable token0 fees.\\n    /// @return fee1 Claimable token1 fees.\\n    function preview(\\n        address pool,\\n        address account\\n    ) external view override returns (uint256 fee0, uint256 fee1) {\\n        AccountState storage st = accountState[pool][account];\\n        PoolState storage ps = poolState[pool];\\n        uint256 balance = ILunarLpFeeSource(pool).balanceOf(account);\\n        uint256 accrued0 = Math.mulDiv(balance, ps.accFee0PerShare, ACC_SCALE);\\n        uint256 accrued1 = Math.mulDiv(balance, ps.accFee1PerShare, ACC_SCALE);\\n        fee0 = st.fee0Accrued;\\n        fee1 = st.fee1Accrued;\\n        if (accrued0 > st.fee0Debt) fee0 += accrued0 - st.fee0Debt;\\n        if (accrued1 > st.fee1Debt) fee1 += accrued1 - st.fee1Debt;\\n    }\\n\\n    /// @notice Updates per-account fee accrual based on balance changes.\\n    /// @param pool Pool address.\\n    /// @param account LP account to update.\\n    /// @param oldBalance Previous LP balance.\\n    /// @param newBalance New LP balance.\\n    function _updateAccount(\\n        address pool,\\n        address account,\\n        uint256 oldBalance,\\n        uint256 newBalance\\n    ) internal {\\n        if (account == address(0)) return;\\n        PoolState storage ps = poolState[pool];\\n        AccountState storage st = accountState[pool][account];\\n        uint256 accrued0 = Math.mulDiv(\\n            oldBalance,\\n            ps.accFee0PerShare,\\n            ACC_SCALE\\n        );\\n        uint256 accrued1 = Math.mulDiv(\\n            oldBalance,\\n            ps.accFee1PerShare,\\n            ACC_SCALE\\n        );\\n        if (accrued0 > st.fee0Debt) st.fee0Accrued += accrued0 - st.fee0Debt;\\n        if (accrued1 > st.fee1Debt) st.fee1Accrued += accrued1 - st.fee1Debt;\\n        st.fee0Debt = Math.mulDiv(newBalance, ps.accFee0PerShare, ACC_SCALE);\\n        st.fee1Debt = Math.mulDiv(newBalance, ps.accFee1PerShare, ACC_SCALE);\\n        emit AccountUpdated(pool, account, oldBalance, newBalance);\\n    }\\n}\\n\",\"keccak256\":\"0x367b4597826787d78987b0a3b6262a98a6a53d8c5e8abf05b6e21179f907bd36\",\"license\":\"MIT\"},\"src/errors/Errors_LunarLpFeeManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nerror LunarLpFeeManager__NotPool();\\nerror LunarLpFeeManager__ZeroAddress();\\nerror LunarLpFeeManager__NothingToClaim();\\nerror LunarLpFeeManager__AmountTooLarge();\\n\",\"keccak256\":\"0xc2764d4ad1585b9b5bf88099b456f36bca9db85923fc834888a96da06d472f38\",\"license\":\"MIT\"},\"src/interfaces/ILunarLpFeeManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\ninterface ILunarLpFeeManager {\\n    /// @notice Records accrued fees for a pool.\\n    /// @param pool Pool address.\\n    /// @param fee0 Token0 fee amount.\\n    /// @param fee1 Token1 fee amount.\\n    /// @param lpSupply Current LP supply.\\n    function onFeesAccrued(\\n        address pool,\\n        uint256 fee0,\\n        uint256 fee1,\\n        uint256 lpSupply\\n    ) external;\\n\\n    /// @notice Updates account fee debts after balance changes.\\n    /// @param pool Pool address.\\n    /// @param account LP account.\\n    /// @param oldBalance Previous balance.\\n    /// @param newBalance New balance.\\n    function onBalanceChange(\\n        address pool,\\n        address account,\\n        uint256 oldBalance,\\n        uint256 newBalance\\n    ) external;\\n\\n    /// @notice Claims accrued fees for the caller.\\n    /// @param pool Pool address.\\n    /// @param to Recipient address.\\n    /// @return fee0 Token0 fees paid.\\n    /// @return fee1 Token1 fees paid.\\n    function claim(\\n        address pool,\\n        address to\\n    ) external returns (uint256 fee0, uint256 fee1);\\n\\n    /// @notice Previews accrued fees for an account.\\n    /// @param pool Pool address.\\n    /// @param account LP account.\\n    /// @return fee0 Token0 fees claimable.\\n    /// @return fee1 Token1 fees claimable.\\n    function preview(\\n        address pool,\\n        address account\\n    ) external view returns (uint256 fee0, uint256 fee1);\\n}\\n\",\"keccak256\":\"0x652c60d2b8baba15cf3581cd87c0a731a4cab1c7b6b3528f7b111e11e8c6785e\",\"license\":\"MIT\"}},\"version\":1}","metadata":{"compiler":{"version":"0.8.28+commit.7893614a"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"account","type":"address"}],"stateMutability":"view","type":"function","name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint128","name":"amount0","type":"uint128"},{"internalType":"uint128","name":"amount1","type":"uint128"}],"stateMutability":"nonpayable","type":"function","name":"collectFees","outputs":[{"internalType":"uint128","name":"","type":"uint128"},{"internalType":"uint128","name":"","type":"uint128"}]}],"devdoc":{"kind":"dev","methods":{"balanceOf(address)":{"params":{"account":"Address to query."},"returns":{"_0":"balance LP token balance."}},"collectFees(address,uint128,uint128)":{"params":{"amount0":"Amount of token0 fees to pay.","amount1":"Amount of token1 fees to pay.","to":"Recipient address."},"returns":{"_0":"paid0 Actual amount of token0 fees transferred.","_1":"paid1 Actual amount of token1 fees transferred."}}},"version":1},"userdoc":{"kind":"user","methods":{"balanceOf(address)":{"notice":"Returns the LP token balance for the account."},"collectFees(address,uint128,uint128)":{"notice":"Transfers accrued fee buckets to the recipient."}},"version":1}},"settings":{"remappings":["@ensdomains/=lib/v4-core/node_modules/@ensdomains/","@lunar/=src/","@openzeppelin/=lib/openzeppelin-contracts/","@uniswap/v4-core/=lib/v4-core/","ds-test/=lib/v4-core/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-gas-snapshot/=lib/v4-periphery/lib/permit2/lib/forge-gas-snapshot/src/","forge-std/=lib/forge-std/src/","halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/","hardhat/=lib/v4-core/node_modules/hardhat/","openzeppelin-contracts/=lib/openzeppelin-contracts/","permit2/=lib/v4-periphery/lib/permit2/","prb-math/=lib/prb-math/src/","solady/=lib/solady/src/","solmate/=lib/v4-core/lib/solmate/","v4-core/=lib/v4-core/src/","v4-periphery/=lib/v4-periphery/"],"optimizer":{"enabled":true,"runs":999999},"metadata":{"useLiteralContent":true,"bytecodeHash":"none"},"compilationTarget":{"src/contracts/LunarFees/LunarLpFeeManager.sol":"ILunarLpFeeSource"},"evmVersion":"cancun","libraries":{},"viaIR":true},"sources":{"lib/openzeppelin-contracts/contracts/utils/Panic.sol":{"keccak256":"0xf7fe324703a64fc51702311dc51562d5cb1497734f074e4f483bfb6717572d7a","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n","license":"MIT"},"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol":{"keccak256":"0xa516cbf1c7d15d3517c2d668601ce016c54395bf5171918a14e2686977465f53","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * IMPORTANT: Deprecated. This storage-based reentrancy guard will be removed and replaced\n * by the {ReentrancyGuardTransient} variant in v6.0.\n *\n * @custom:stateless\n */\nabstract contract ReentrancyGuard {\n    using StorageSlot for bytes32;\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant REENTRANCY_GUARD_STORAGE =\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _reentrancyGuardStorageSlot().getUint256Slot().value = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    /**\n     * @dev A `view` only version of {nonReentrant}. Use to block view functions\n     * from being called, preventing reading from inconsistent contract state.\n     *\n     * CAUTION: This is a \"view\" modifier and does not change the reentrancy\n     * status. Use it only on view functions. For payable or non-payable functions,\n     * use the standard {nonReentrant} modifier instead.\n     */\n    modifier nonReentrantView() {\n        _nonReentrantBeforeView();\n        _;\n    }\n\n    function _nonReentrantBeforeView() private view {\n        if (_reentrancyGuardEntered()) {\n            revert ReentrancyGuardReentrantCall();\n        }\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        _nonReentrantBeforeView();\n\n        // Any calls to nonReentrant after this point will fail\n        _reentrancyGuardStorageSlot().getUint256Slot().value = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _reentrancyGuardStorageSlot().getUint256Slot().value = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _reentrancyGuardStorageSlot().getUint256Slot().value == ENTERED;\n    }\n\n    function _reentrancyGuardStorageSlot() internal pure virtual returns (bytes32) {\n        return REENTRANCY_GUARD_STORAGE;\n    }\n}\n","license":"MIT"},"lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol":{"keccak256":"0xcf74f855663ce2ae00ed8352666b7935f6cddea2932fdf2c3ecd30a9b1cd0e97","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n","license":"MIT"},"lib/openzeppelin-contracts/contracts/utils/math/Math.sol":{"keccak256":"0xc272e2d5e7144ec7564f6aa231ed4bc423497997f99f408a235ff2016d25e785","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2 + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2 + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2 and mod 2 - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2 + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `condition ? a : b`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `condition ? a : b`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // (a + b) / 2 can overflow.\n            return (a & b) + (a ^ b) / 2;\n        }\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv  1 mod 2.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax  1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory buffer) private pure returns (bool) {\n        uint256 chunk;\n        for (uint256 i = 0; i < buffer.length; i += 0x20) {\n            // See _unsafeReadBytesOffset from utils/Bytes.sol\n            assembly (\"memory-safe\") {\n                chunk := mload(add(add(buffer, 0x20), i))\n            }\n            if (chunk >> (8 * saturatingSub(i + 0x20, buffer.length)) != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\n            // This is going to be our x_0 (and _0)\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\n            //              = ((x_n + a) / (2 * x_n)) - a\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\n            //              = (x_n - a) / (2 * x_n)\n            //              = ((x_n - a) / (2 * x_n))\n            //               0\n            // Which proves that for all n  1, sqrt(a)  x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // _{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\n            //         = | _n / (2 * x_n) |\n            //         = _n / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // _1 = _0 / | (2 * x_0) |\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\n            //      2**(2*e-4) / (3 * 2**(e-1))\n            //      2**(e-3) / 3\n            //      2**(e-3-log2(3))\n            //      2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\n            // _{n+1} = _n / | (2 * x_n) |\n            //          (2**(e-k)) / (2 * 2**(e-1))\n            //          2**(2*e-2*k) / 2**e\n            //          2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\n\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n\n    /**\n     * @dev Counts the number of leading zero bits in a uint256.\n     */\n    function clz(uint256 x) internal pure returns (uint256) {\n        return ternary(x == 0, 256, 255 - log2(x));\n    }\n}\n","license":"MIT"},"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol":{"keccak256":"0x195533c86d0ef72bcc06456a4f66a9b941f38eb403739b00f21fd7c1abd1ae54","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n","license":"MIT"},"src/contracts/LunarFees/LunarLpFeeManager.sol":{"keccak256":"0x367b4597826787d78987b0a3b6262a98a6a53d8c5e8abf05b6e21179f907bd36","urls":[],"content":"// SPDX-License-Identifier: MIT\n//\n//                \n//                                  \n//                          \n//                                                          \n//                                                            \n//                                                              \n//                                                              \n//                                                              \n//                               \n//                              \n//          \n//                                                          \n//                                                            \n//                                                     \n//                                                           \n//                                                              \n//                \n//\npragma solidity ^0.8.21;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {ILunarLpFeeManager} from \"@lunar/interfaces/ILunarLpFeeManager.sol\";\nimport {LunarLpFeeManager__NotPool, LunarLpFeeManager__ZeroAddress, LunarLpFeeManager__NothingToClaim, LunarLpFeeManager__AmountTooLarge} from \"@lunar/errors/Errors_LunarLpFeeManager.sol\";\n\n/// @notice Minimal pool interface used by the LP fee manager to pull fees.\ninterface ILunarLpFeeSource {\n    /// @notice Returns the LP token balance for the account.\n    /// @param account Address to query.\n    /// @return balance LP token balance.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers accrued fee buckets to the recipient.\n    /// @param to Recipient address.\n    /// @param amount0 Amount of token0 fees to pay.\n    /// @param amount1 Amount of token1 fees to pay.\n    /// @return paid0 Actual amount of token0 fees transferred.\n    /// @return paid1 Actual amount of token1 fees transferred.\n    function collectFees(\n        address to,\n        uint128 amount0,\n        uint128 amount1\n    ) external returns (uint128, uint128);\n}\n\n/// @notice Centralized LP fee accounting manager shared by all pools.\ncontract LunarLpFeeManager is ILunarLpFeeManager, ReentrancyGuard {\n    uint256 public constant ACC_SCALE = 1e18;\n\n    struct PoolState {\n        uint256 accFee0PerShare;\n        uint256 accFee1PerShare;\n    }\n\n    struct AccountState {\n        uint256 fee0Debt;\n        uint256 fee1Debt;\n        uint256 fee0Accrued;\n        uint256 fee1Accrued;\n    }\n\n    mapping(address => PoolState) public poolState;\n    mapping(address => mapping(address => AccountState)) public accountState;\n\n    event FeesAccrued(address indexed pool, uint256 fee0, uint256 fee1);\n    event AccountUpdated(\n        address indexed pool,\n        address indexed account,\n        uint256 oldBalance,\n        uint256 newBalance\n    );\n    event FeesClaimed(\n        address indexed pool,\n        address indexed account,\n        address indexed to,\n        uint256 fee0,\n        uint256 fee1\n    );\n\n    /// @notice Records new fees accrued by a pool and updates per-share accumulators.\n    /// @dev Only callable by the pool that accrued the fees.\n    /// @param pool Pool address emitting the fees.\n    /// @param fee0 Token0 fee amount accrued in the pool.\n    /// @param fee1 Token1 fee amount accrued in the pool.\n    /// @param lpSupply Current LP supply of the pool.\n    function onFeesAccrued(\n        address pool,\n        uint256 fee0,\n        uint256 fee1,\n        uint256 lpSupply\n    ) external override {\n        if (msg.sender != pool) revert LunarLpFeeManager__NotPool();\n        if (lpSupply == 0) return;\n        PoolState storage ps = poolState[pool];\n        if (fee0 > 0)\n            ps.accFee0PerShare += Math.mulDiv(fee0, ACC_SCALE, lpSupply);\n        if (fee1 > 0)\n            ps.accFee1PerShare += Math.mulDiv(fee1, ACC_SCALE, lpSupply);\n        if (fee0 > 0 || fee1 > 0) emit FeesAccrued(pool, fee0, fee1);\n    }\n\n    /// @notice Updates fee debts when an LP balance changes.\n    /// @dev Only callable by the pool whose balances changed.\n    /// @param pool Pool address.\n    /// @param account LP account whose balance changed.\n    /// @param oldBalance Previous LP balance.\n    /// @param newBalance New LP balance.\n    function onBalanceChange(\n        address pool,\n        address account,\n        uint256 oldBalance,\n        uint256 newBalance\n    ) external override {\n        if (msg.sender != pool) revert LunarLpFeeManager__NotPool();\n        _updateAccount(pool, account, oldBalance, newBalance);\n    }\n\n    /// @notice Claims accrued fees for the caller from a pool.\n    /// @param pool Pool address.\n    /// @param to Recipient of the fee payout.\n    /// @return fee0 Amount of token0 fees paid.\n    /// @return fee1 Amount of token1 fees paid.\n    function claim(\n        address pool,\n        address to\n    ) external override nonReentrant returns (uint256 fee0, uint256 fee1) {\n        if (to == address(0)) revert LunarLpFeeManager__ZeroAddress();\n        ILunarLpFeeSource source = ILunarLpFeeSource(pool);\n        uint256 balance = source.balanceOf(msg.sender);\n        _updateAccount(pool, msg.sender, balance, balance);\n\n        AccountState storage st = accountState[pool][msg.sender];\n        fee0 = st.fee0Accrued;\n        fee1 = st.fee1Accrued;\n        if (fee0 == 0 && fee1 == 0) revert LunarLpFeeManager__NothingToClaim();\n        if (fee0 > type(uint128).max || fee1 > type(uint128).max) {\n            revert LunarLpFeeManager__AmountTooLarge();\n        }\n        st.fee0Accrued = 0;\n        st.fee1Accrued = 0;\n\n        (uint128 paid0, uint128 paid1) = source.collectFees(\n            to,\n            uint128(fee0),\n            uint128(fee1)\n        );\n        fee0 = paid0;\n        fee1 = paid1;\n        emit FeesClaimed(pool, msg.sender, to, fee0, fee1);\n    }\n\n    /// @notice Previews the claimable fees for an account without modifying state.\n    /// @param pool Pool address.\n    /// @param account Account to preview.\n    /// @return fee0 Claimable token0 fees.\n    /// @return fee1 Claimable token1 fees.\n    function preview(\n        address pool,\n        address account\n    ) external view override returns (uint256 fee0, uint256 fee1) {\n        AccountState storage st = accountState[pool][account];\n        PoolState storage ps = poolState[pool];\n        uint256 balance = ILunarLpFeeSource(pool).balanceOf(account);\n        uint256 accrued0 = Math.mulDiv(balance, ps.accFee0PerShare, ACC_SCALE);\n        uint256 accrued1 = Math.mulDiv(balance, ps.accFee1PerShare, ACC_SCALE);\n        fee0 = st.fee0Accrued;\n        fee1 = st.fee1Accrued;\n        if (accrued0 > st.fee0Debt) fee0 += accrued0 - st.fee0Debt;\n        if (accrued1 > st.fee1Debt) fee1 += accrued1 - st.fee1Debt;\n    }\n\n    /// @notice Updates per-account fee accrual based on balance changes.\n    /// @param pool Pool address.\n    /// @param account LP account to update.\n    /// @param oldBalance Previous LP balance.\n    /// @param newBalance New LP balance.\n    function _updateAccount(\n        address pool,\n        address account,\n        uint256 oldBalance,\n        uint256 newBalance\n    ) internal {\n        if (account == address(0)) return;\n        PoolState storage ps = poolState[pool];\n        AccountState storage st = accountState[pool][account];\n        uint256 accrued0 = Math.mulDiv(\n            oldBalance,\n            ps.accFee0PerShare,\n            ACC_SCALE\n        );\n        uint256 accrued1 = Math.mulDiv(\n            oldBalance,\n            ps.accFee1PerShare,\n            ACC_SCALE\n        );\n        if (accrued0 > st.fee0Debt) st.fee0Accrued += accrued0 - st.fee0Debt;\n        if (accrued1 > st.fee1Debt) st.fee1Accrued += accrued1 - st.fee1Debt;\n        st.fee0Debt = Math.mulDiv(newBalance, ps.accFee0PerShare, ACC_SCALE);\n        st.fee1Debt = Math.mulDiv(newBalance, ps.accFee1PerShare, ACC_SCALE);\n        emit AccountUpdated(pool, account, oldBalance, newBalance);\n    }\n}\n","license":"MIT"},"src/errors/Errors_LunarLpFeeManager.sol":{"keccak256":"0xc2764d4ad1585b9b5bf88099b456f36bca9db85923fc834888a96da06d472f38","urls":[],"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nerror LunarLpFeeManager__NotPool();\nerror LunarLpFeeManager__ZeroAddress();\nerror LunarLpFeeManager__NothingToClaim();\nerror LunarLpFeeManager__AmountTooLarge();\n","license":"MIT"},"src/interfaces/ILunarLpFeeManager.sol":{"keccak256":"0x652c60d2b8baba15cf3581cd87c0a731a4cab1c7b6b3528f7b111e11e8c6785e","urls":[],"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\ninterface ILunarLpFeeManager {\n    /// @notice Records accrued fees for a pool.\n    /// @param pool Pool address.\n    /// @param fee0 Token0 fee amount.\n    /// @param fee1 Token1 fee amount.\n    /// @param lpSupply Current LP supply.\n    function onFeesAccrued(\n        address pool,\n        uint256 fee0,\n        uint256 fee1,\n        uint256 lpSupply\n    ) external;\n\n    /// @notice Updates account fee debts after balance changes.\n    /// @param pool Pool address.\n    /// @param account LP account.\n    /// @param oldBalance Previous balance.\n    /// @param newBalance New balance.\n    function onBalanceChange(\n        address pool,\n        address account,\n        uint256 oldBalance,\n        uint256 newBalance\n    ) external;\n\n    /// @notice Claims accrued fees for the caller.\n    /// @param pool Pool address.\n    /// @param to Recipient address.\n    /// @return fee0 Token0 fees paid.\n    /// @return fee1 Token1 fees paid.\n    function claim(\n        address pool,\n        address to\n    ) external returns (uint256 fee0, uint256 fee1);\n\n    /// @notice Previews accrued fees for an account.\n    /// @param pool Pool address.\n    /// @param account LP account.\n    /// @return fee0 Token0 fees claimable.\n    /// @return fee1 Token1 fees claimable.\n    function preview(\n        address pool,\n        address account\n    ) external view returns (uint256 fee0, uint256 fee1);\n}\n","license":"MIT"}},"version":1},"ast":{"absolutePath":"src/contracts/LunarFees/LunarLpFeeManager.sol","id":8651,"exportedSymbols":{"ILunarLpFeeManager":[22593],"ILunarLpFeeSource":[8123],"LunarLpFeeManager":[8650],"LunarLpFeeManager__AmountTooLarge":[22016],"LunarLpFeeManager__NotPool":[22010],"LunarLpFeeManager__NothingToClaim":[22014],"LunarLpFeeManager__ZeroAddress":[22012],"Math":[3318],"ReentrancyGuard":[1245]},"nodeType":"SourceUnit","src":"3215:7130:20","nodes":[{"id":8088,"nodeType":"PragmaDirective","src":"3215:24:20","nodes":[],"literals":["solidity","^","0.8",".21"]},{"id":8090,"nodeType":"ImportDirective","src":"3241:65:20","nodes":[],"absolutePath":"lib/openzeppelin-contracts/contracts/utils/math/Math.sol","file":"@openzeppelin/contracts/utils/math/Math.sol","nameLocation":"-1:-1:-1","scope":8651,"sourceUnit":3319,"symbolAliases":[{"foreign":{"id":8089,"name":"Math","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":3318,"src":"3249:4:20","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":8092,"nodeType":"ImportDirective","src":"3307:82:20","nodes":[],"absolutePath":"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol","file":"@openzeppelin/contracts/utils/ReentrancyGuard.sol","nameLocation":"-1:-1:-1","scope":8651,"sourceUnit":1246,"symbolAliases":[{"foreign":{"id":8091,"name":"ReentrancyGuard","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":1245,"src":"3315:15:20","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":8094,"nodeType":"ImportDirective","src":"3390:76:20","nodes":[],"absolutePath":"src/interfaces/ILunarLpFeeManager.sol","file":"@lunar/interfaces/ILunarLpFeeManager.sol","nameLocation":"-1:-1:-1","scope":8651,"sourceUnit":22594,"symbolAliases":[{"foreign":{"id":8093,"name":"ILunarLpFeeManager","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":22593,"src":"3398:18:20","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":8099,"nodeType":"ImportDirective","src":"3467:188:20","nodes":[],"absolutePath":"src/errors/Errors_LunarLpFeeManager.sol","file":"@lunar/errors/Errors_LunarLpFeeManager.sol","nameLocation":"-1:-1:-1","scope":8651,"sourceUnit":22017,"symbolAliases":[{"foreign":{"id":8095,"name":"LunarLpFeeManager__NotPool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":22010,"src":"3475:26:20","typeDescriptions":{}},"nameLocation":"-1:-1:-1"},{"foreign":{"id":8096,"name":"LunarLpFeeManager__ZeroAddress","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":22012,"src":"3503:30:20","typeDescriptions":{}},"nameLocation":"-1:-1:-1"},{"foreign":{"id":8097,"name":"LunarLpFeeManager__NothingToClaim","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":22014,"src":"3535:33:20","typeDescriptions":{}},"nameLocation":"-1:-1:-1"},{"foreign":{"id":8098,"name":"LunarLpFeeManager__AmountTooLarge","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":22016,"src":"3570:33:20","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":8123,"nodeType":"ContractDefinition","src":"3733:723:20","nodes":[{"id":8108,"nodeType":"FunctionDefinition","src":"3912:68:20","nodes":[],"documentation":{"id":8101,"nodeType":"StructuredDocumentation","src":"3767:140:20","text":"@notice Returns the LP token balance for the account.\n @param account Address to query.\n @return balance LP token balance."},"functionSelector":"70a08231","implemented":false,"kind":"function","modifiers":[],"name":"balanceOf","nameLocation":"3921:9:20","parameters":{"id":8104,"nodeType":"ParameterList","parameters":[{"constant":false,"id":8103,"mutability":"mutable","name":"account","nameLocation":"3939:7:20","nodeType":"VariableDeclaration","scope":8108,"src":"3931:15:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8102,"name":"address","nodeType":"ElementaryTypeName","src":"3931:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"3930:17:20"},"returnParameters":{"id":8107,"nodeType":"ParameterList","parameters":[{"constant":false,"id":8106,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":8108,"src":"3971:7:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8105,"name":"uint256","nodeType":"ElementaryTypeName","src":"3971:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"3970:9:20"},"scope":8123,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":8122,"nodeType":"FunctionDefinition","src":"4321:133:20","nodes":[],"documentation":{"id":8109,"nodeType":"StructuredDocumentation","src":"3986:330:20","text":"@notice Transfers accrued fee buckets to the recipient.\n @param to Recipient address.\n @param amount0 Amount of token0 fees to pay.\n @param amount1 Amount of token1 fees to pay.\n @return paid0 Actual amount of token0 fees transferred.\n @return paid1 Actual amount of token1 fees transferred."},"functionSelector":"755f2e45","implemented":false,"kind":"function","modifiers":[],"name":"collectFees","nameLocation":"4330:11:20","parameters":{"id":8116,"nodeType":"ParameterList","parameters":[{"constant":false,"id":8111,"mutability":"mutable","name":"to","nameLocation":"4359:2:20","nodeType":"VariableDeclaration","scope":8122,"src":"4351:10:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8110,"name":"address","nodeType":"ElementaryTypeName","src":"4351:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":8113,"mutability":"mutable","name":"amount0","nameLocation":"4379:7:20","nodeType":"VariableDeclaration","scope":8122,"src":"4371:15:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"},"typeName":{"id":8112,"name":"uint128","nodeType":"ElementaryTypeName","src":"4371:7:20","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"}},"visibility":"internal"},{"constant":false,"id":8115,"mutability":"mutable","name":"amount1","nameLocation":"4404:7:20","nodeType":"VariableDeclaration","scope":8122,"src":"4396:15:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"},"typeName":{"id":8114,"name":"uint128","nodeType":"ElementaryTypeName","src":"4396:7:20","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"}},"visibility":"internal"}],"src":"4341:76:20"},"returnParameters":{"id":8121,"nodeType":"ParameterList","parameters":[{"constant":false,"id":8118,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":8122,"src":"4436:7:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"},"typeName":{"id":8117,"name":"uint128","nodeType":"ElementaryTypeName","src":"4436:7:20","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"}},"visibility":"internal"},{"constant":false,"id":8120,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":8122,"src":"4445:7:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"},"typeName":{"id":8119,"name":"uint128","nodeType":"ElementaryTypeName","src":"4445:7:20","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"}},"visibility":"internal"}],"src":"4435:18:20"},"scope":8123,"stateMutability":"nonpayable","virtual":false,"visibility":"external"}],"abstract":false,"baseContracts":[],"canonicalName":"ILunarLpFeeSource","contractDependencies":[],"contractKind":"interface","documentation":{"id":8100,"nodeType":"StructuredDocumentation","src":"3657:76:20","text":"@notice Minimal pool interface used by the LP fee manager to pull fees."},"fullyImplemented":false,"linearizedBaseContracts":[8123],"name":"ILunarLpFeeSource","nameLocation":"3743:17:20","scope":8651,"usedErrors":[],"usedEvents":[]},{"id":8650,"nodeType":"ContractDefinition","src":"4529:5815:20","nodes":[{"id":8131,"nodeType":"VariableDeclaration","src":"4601:40:20","nodes":[],"constant":true,"functionSelector":"6afc511b","mutability":"constant","name":"ACC_SCALE","nameLocation":"4625:9:20","scope":8650,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8129,"name":"uint256","nodeType":"ElementaryTypeName","src":"4601:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"value":{"hexValue":"31653138","id":8130,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"4637:4:20","typeDescriptions":{"typeIdentifier":"t_rational_1000000000000000000_by_1","typeString":"int_const 1000000000000000000"},"value":"1e18"},"visibility":"public"},{"id":8136,"nodeType":"StructDefinition","src":"4648:90:20","nodes":[],"canonicalName":"LunarLpFeeManager.PoolState","members":[{"constant":false,"id":8133,"mutability":"mutable","name":"accFee0PerShare","nameLocation":"4683:15:20","nodeType":"VariableDeclaration","scope":8136,"src":"4675:23:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8132,"name":"uint256","nodeType":"ElementaryTypeName","src":"4675:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":8135,"mutability":"mutable","name":"accFee1PerShare","nameLocation":"4716:15:20","nodeType":"VariableDeclaration","scope":8136,"src":"4708:23:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8134,"name":"uint256","nodeType":"ElementaryTypeName","src":"4708:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"name":"PoolState","nameLocation":"4655:9:20","scope":8650,"visibility":"public"},{"id":8145,"nodeType":"StructDefinition","src":"4744:137:20","nodes":[],"canonicalName":"LunarLpFeeManager.AccountState","members":[{"constant":false,"id":8138,"mutability":"mutable","name":"fee0Debt","nameLocation":"4782:8:20","nodeType":"VariableDeclaration","scope":8145,"src":"4774:16:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8137,"name":"uint256","nodeType":"ElementaryTypeName","src":"4774:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":8140,"mutability":"mutable","name":"fee1Debt","nameLocation":"4808:8:20","nodeType":"VariableDeclaration","scope":8145,"src":"4800:16:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8139,"name":"uint256","nodeType":"ElementaryTypeName","src":"4800:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":8142,"mutability":"mutable","name":"fee0Accrued","nameLocation":"4834:11:20","nodeType":"VariableDeclaration","scope":8145,"src":"4826:19:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8141,"name":"uint256","nodeType":"ElementaryTypeName","src":"4826:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":8144,"mutability":"mutable","name":"fee1Accrued","nameLocation":"4863:11:20","nodeType":"VariableDeclaration","scope":8145,"src":"4855:19:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8143,"name":"uint256","nodeType":"ElementaryTypeName","src":"4855:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"name":"AccountState","nameLocation":"4751:12:20","scope":8650,"visibility":"public"},{"id":8150,"nodeType":"VariableDeclaration","src":"4887:46:20","nodes":[],"constant":false,"functionSelector":"99cd120f","mutability":"mutable","name":"poolState","nameLocation":"4924:9:20","scope":8650,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_struct$_PoolState_$8136_storage_$","typeString":"mapping(address => struct LunarLpFeeManager.PoolState)"},"typeName":{"id":8149,"keyName":"","keyNameLocation":"-1:-1:-1","keyType":{"id":8146,"name":"address","nodeType":"ElementaryTypeName","src":"4895:7:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Mapping","src":"4887:29:20","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_struct$_PoolState_$8136_storage_$","typeString":"mapping(address => struct LunarLpFeeManager.PoolState)"},"valueName":"","valueNameLocation":"-1:-1:-1","valueType":{"id":8148,"nodeType":"UserDefinedTypeName","pathNode":{"id":8147,"name":"PoolState","nameLocations":["4906:9:20"],"nodeType":"IdentifierPath","referencedDeclaration":8136,"src":"4906:9:20"},"referencedDeclaration":8136,"src":"4906:9:20","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage_ptr","typeString":"struct LunarLpFeeManager.PoolState"}}},"visibility":"public"},{"id":8157,"nodeType":"VariableDeclaration","src":"4939:72:20","nodes":[],"constant":false,"functionSelector":"e4f51271","mutability":"mutable","name":"accountState","nameLocation":"4999:12:20","scope":8650,"stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_struct$_AccountState_$8145_storage_$_$","typeString":"mapping(address => mapping(address => struct LunarLpFeeManager.AccountState))"},"typeName":{"id":8156,"keyName":"","keyNameLocation":"-1:-1:-1","keyType":{"id":8151,"name":"address","nodeType":"ElementaryTypeName","src":"4947:7:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Mapping","src":"4939:52:20","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_struct$_AccountState_$8145_storage_$_$","typeString":"mapping(address => mapping(address => struct LunarLpFeeManager.AccountState))"},"valueName":"","valueNameLocation":"-1:-1:-1","valueType":{"id":8155,"keyName":"","keyNameLocation":"-1:-1:-1","keyType":{"id":8152,"name":"address","nodeType":"ElementaryTypeName","src":"4966:7:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Mapping","src":"4958:32:20","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_struct$_AccountState_$8145_storage_$","typeString":"mapping(address => struct LunarLpFeeManager.AccountState)"},"valueName":"","valueNameLocation":"-1:-1:-1","valueType":{"id":8154,"nodeType":"UserDefinedTypeName","pathNode":{"id":8153,"name":"AccountState","nameLocations":["4977:12:20"],"nodeType":"IdentifierPath","referencedDeclaration":8145,"src":"4977:12:20"},"referencedDeclaration":8145,"src":"4977:12:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState"}}}},"visibility":"public"},{"id":8165,"nodeType":"EventDefinition","src":"5018:68:20","nodes":[],"anonymous":false,"eventSelector":"d2f36b7fd206a8b1cc41c911e5097cad7b212c0fdb230311dd2568194e7d9a5d","name":"FeesAccrued","nameLocation":"5024:11:20","parameters":{"id":8164,"nodeType":"ParameterList","parameters":[{"constant":false,"id":8159,"indexed":true,"mutability":"mutable","name":"pool","nameLocation":"5052:4:20","nodeType":"VariableDeclaration","scope":8165,"src":"5036:20:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8158,"name":"address","nodeType":"ElementaryTypeName","src":"5036:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":8161,"indexed":false,"mutability":"mutable","name":"fee0","nameLocation":"5066:4:20","nodeType":"VariableDeclaration","scope":8165,"src":"5058:12:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8160,"name":"uint256","nodeType":"ElementaryTypeName","src":"5058:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":8163,"indexed":false,"mutability":"mutable","name":"fee1","nameLocation":"5080:4:20","nodeType":"VariableDeclaration","scope":8165,"src":"5072:12:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8162,"name":"uint256","nodeType":"ElementaryTypeName","src":"5072:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"5035:50:20"}},{"id":8175,"nodeType":"EventDefinition","src":"5091:146:20","nodes":[],"anonymous":false,"eventSelector":"80708e4f0498a8dae0103b3221fdc87f881204f807331e98f9e77685e37b1b96","name":"AccountUpdated","nameLocation":"5097:14:20","parameters":{"id":8174,"nodeType":"ParameterList","parameters":[{"constant":false,"id":8167,"indexed":true,"mutability":"mutable","name":"pool","nameLocation":"5137:4:20","nodeType":"VariableDeclaration","scope":8175,"src":"5121:20:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8166,"name":"address","nodeType":"ElementaryTypeName","src":"5121:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":8169,"indexed":true,"mutability":"mutable","name":"account","nameLocation":"5167:7:20","nodeType":"VariableDeclaration","scope":8175,"src":"5151:23:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8168,"name":"address","nodeType":"ElementaryTypeName","src":"5151:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":8171,"indexed":false,"mutability":"mutable","name":"oldBalance","nameLocation":"5192:10:20","nodeType":"VariableDeclaration","scope":8175,"src":"5184:18:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8170,"name":"uint256","nodeType":"ElementaryTypeName","src":"5184:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":8173,"indexed":false,"mutability":"mutable","name":"newBalance","nameLocation":"5220:10:20","nodeType":"VariableDeclaration","scope":8175,"src":"5212:18:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8172,"name":"uint256","nodeType":"ElementaryTypeName","src":"5212:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"5111:125:20"}},{"id":8187,"nodeType":"EventDefinition","src":"5242:159:20","nodes":[],"anonymous":false,"eventSelector":"d377f58cbc83f844989775f0d4bfa247dbee70bf3d851b8c5f0e0fe51d3b6ef9","name":"FeesClaimed","nameLocation":"5248:11:20","parameters":{"id":8186,"nodeType":"ParameterList","parameters":[{"constant":false,"id":8177,"indexed":true,"mutability":"mutable","name":"pool","nameLocation":"5285:4:20","nodeType":"VariableDeclaration","scope":8187,"src":"5269:20:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8176,"name":"address","nodeType":"ElementaryTypeName","src":"5269:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":8179,"indexed":true,"mutability":"mutable","name":"account","nameLocation":"5315:7:20","nodeType":"VariableDeclaration","scope":8187,"src":"5299:23:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8178,"name":"address","nodeType":"ElementaryTypeName","src":"5299:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":8181,"indexed":true,"mutability":"mutable","name":"to","nameLocation":"5348:2:20","nodeType":"VariableDeclaration","scope":8187,"src":"5332:18:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8180,"name":"address","nodeType":"ElementaryTypeName","src":"5332:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":8183,"indexed":false,"mutability":"mutable","name":"fee0","nameLocation":"5368:4:20","nodeType":"VariableDeclaration","scope":8187,"src":"5360:12:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8182,"name":"uint256","nodeType":"ElementaryTypeName","src":"5360:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":8185,"indexed":false,"mutability":"mutable","name":"fee1","nameLocation":"5390:4:20","nodeType":"VariableDeclaration","scope":8187,"src":"5382:12:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8184,"name":"uint256","nodeType":"ElementaryTypeName","src":"5382:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"5259:141:20"}},{"id":8265,"nodeType":"FunctionDefinition","src":"5781:560:20","nodes":[],"body":{"id":8264,"nodeType":"Block","src":"5920:421:20","nodes":[],"statements":[{"condition":{"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":8203,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"expression":{"id":8200,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"5934:3:20","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":8201,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"5938:6:20","memberName":"sender","nodeType":"MemberAccess","src":"5934:10:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"id":8202,"name":"pool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8190,"src":"5948:4:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"src":"5934:18:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":8207,"nodeType":"IfStatement","src":"5930:59:20","trueBody":{"errorCall":{"arguments":[],"expression":{"argumentTypes":[],"id":8204,"name":"LunarLpFeeManager__NotPool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":22010,"src":"5961:26:20","typeDescriptions":{"typeIdentifier":"t_function_error_pure$__$returns$_t_error_$","typeString":"function () pure returns (error)"}},"id":8205,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"5961:28:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_error","typeString":"error"}},"id":8206,"nodeType":"RevertStatement","src":"5954:35:20"}},{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8210,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8208,"name":"lpSupply","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8196,"src":"6003:8:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"hexValue":"30","id":8209,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"6015:1:20","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"6003:13:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":8212,"nodeType":"IfStatement","src":"5999:26:20","trueBody":{"functionReturnParameters":8199,"id":8211,"nodeType":"Return","src":"6018:7:20"}},{"assignments":[8215],"declarations":[{"constant":false,"id":8215,"mutability":"mutable","name":"ps","nameLocation":"6052:2:20","nodeType":"VariableDeclaration","scope":8264,"src":"6034:20:20","stateVariable":false,"storageLocation":"storage","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage_ptr","typeString":"struct LunarLpFeeManager.PoolState"},"typeName":{"id":8214,"nodeType":"UserDefinedTypeName","pathNode":{"id":8213,"name":"PoolState","nameLocations":["6034:9:20"],"nodeType":"IdentifierPath","referencedDeclaration":8136,"src":"6034:9:20"},"referencedDeclaration":8136,"src":"6034:9:20","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage_ptr","typeString":"struct LunarLpFeeManager.PoolState"}},"visibility":"internal"}],"id":8219,"initialValue":{"baseExpression":{"id":8216,"name":"poolState","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8150,"src":"6057:9:20","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_struct$_PoolState_$8136_storage_$","typeString":"mapping(address => struct LunarLpFeeManager.PoolState storage ref)"}},"id":8218,"indexExpression":{"id":8217,"name":"pool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8190,"src":"6067:4:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"6057:15:20","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage","typeString":"struct LunarLpFeeManager.PoolState storage ref"}},"nodeType":"VariableDeclarationStatement","src":"6034:38:20"},{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8222,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8220,"name":"fee0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8192,"src":"6086:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"hexValue":"30","id":8221,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"6093:1:20","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"6086:8:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":8234,"nodeType":"IfStatement","src":"6082:86:20","trueBody":{"expression":{"id":8232,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"expression":{"id":8223,"name":"ps","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8215,"src":"6108:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage_ptr","typeString":"struct LunarLpFeeManager.PoolState storage pointer"}},"id":8225,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"memberLocation":"6111:15:20","memberName":"accFee0PerShare","nodeType":"MemberAccess","referencedDeclaration":8133,"src":"6108:18:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"+=","rightHandSide":{"arguments":[{"id":8228,"name":"fee0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8192,"src":"6142:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":8229,"name":"ACC_SCALE","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8131,"src":"6148:9:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":8230,"name":"lpSupply","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8196,"src":"6159:8:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"expression":{"id":8226,"name":"Math","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":3318,"src":"6130:4:20","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Math_$3318_$","typeString":"type(library Math)"}},"id":8227,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"6135:6:20","memberName":"mulDiv","nodeType":"MemberAccess","referencedDeclaration":2189,"src":"6130:11:20","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$returns$_t_uint256_$","typeString":"function (uint256,uint256,uint256) pure returns (uint256)"}},"id":8231,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6130:38:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"6108:60:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8233,"nodeType":"ExpressionStatement","src":"6108:60:20"}},{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8237,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8235,"name":"fee1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8194,"src":"6182:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"hexValue":"30","id":8236,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"6189:1:20","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"6182:8:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":8249,"nodeType":"IfStatement","src":"6178:86:20","trueBody":{"expression":{"id":8247,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"expression":{"id":8238,"name":"ps","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8215,"src":"6204:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage_ptr","typeString":"struct LunarLpFeeManager.PoolState storage pointer"}},"id":8240,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"memberLocation":"6207:15:20","memberName":"accFee1PerShare","nodeType":"MemberAccess","referencedDeclaration":8135,"src":"6204:18:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"+=","rightHandSide":{"arguments":[{"id":8243,"name":"fee1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8194,"src":"6238:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":8244,"name":"ACC_SCALE","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8131,"src":"6244:9:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":8245,"name":"lpSupply","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8196,"src":"6255:8:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"expression":{"id":8241,"name":"Math","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":3318,"src":"6226:4:20","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Math_$3318_$","typeString":"type(library Math)"}},"id":8242,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"6231:6:20","memberName":"mulDiv","nodeType":"MemberAccess","referencedDeclaration":2189,"src":"6226:11:20","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$returns$_t_uint256_$","typeString":"function (uint256,uint256,uint256) pure returns (uint256)"}},"id":8246,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6226:38:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"6204:60:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8248,"nodeType":"ExpressionStatement","src":"6204:60:20"}},{"condition":{"commonType":{"typeIdentifier":"t_bool","typeString":"bool"},"id":8256,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8252,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8250,"name":"fee0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8192,"src":"6278:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"hexValue":"30","id":8251,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"6285:1:20","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"6278:8:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"nodeType":"BinaryOperation","operator":"||","rightExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8255,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8253,"name":"fee1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8194,"src":"6290:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"hexValue":"30","id":8254,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"6297:1:20","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"6290:8:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"src":"6278:20:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":8263,"nodeType":"IfStatement","src":"6274:60:20","trueBody":{"eventCall":{"arguments":[{"id":8258,"name":"pool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8190,"src":"6317:4:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":8259,"name":"fee0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8192,"src":"6323:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":8260,"name":"fee1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8194,"src":"6329:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":8257,"name":"FeesAccrued","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8165,"src":"6305:11:20","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_address_$_t_uint256_$_t_uint256_$returns$__$","typeString":"function (address,uint256,uint256)"}},"id":8261,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6305:29:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":8262,"nodeType":"EmitStatement","src":"6300:34:20"}}]},"baseFunctions":[22556],"documentation":{"id":8188,"nodeType":"StructuredDocumentation","src":"5407:369:20","text":"@notice Records new fees accrued by a pool and updates per-share accumulators.\n @dev Only callable by the pool that accrued the fees.\n @param pool Pool address emitting the fees.\n @param fee0 Token0 fee amount accrued in the pool.\n @param fee1 Token1 fee amount accrued in the pool.\n @param lpSupply Current LP supply of the pool."},"functionSelector":"d0ac1267","implemented":true,"kind":"function","modifiers":[],"name":"onFeesAccrued","nameLocation":"5790:13:20","overrides":{"id":8198,"nodeType":"OverrideSpecifier","overrides":[],"src":"5911:8:20"},"parameters":{"id":8197,"nodeType":"ParameterList","parameters":[{"constant":false,"id":8190,"mutability":"mutable","name":"pool","nameLocation":"5821:4:20","nodeType":"VariableDeclaration","scope":8265,"src":"5813:12:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8189,"name":"address","nodeType":"ElementaryTypeName","src":"5813:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":8192,"mutability":"mutable","name":"fee0","nameLocation":"5843:4:20","nodeType":"VariableDeclaration","scope":8265,"src":"5835:12:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8191,"name":"uint256","nodeType":"ElementaryTypeName","src":"5835:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":8194,"mutability":"mutable","name":"fee1","nameLocation":"5865:4:20","nodeType":"VariableDeclaration","scope":8265,"src":"5857:12:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8193,"name":"uint256","nodeType":"ElementaryTypeName","src":"5857:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":8196,"mutability":"mutable","name":"lpSupply","nameLocation":"5887:8:20","nodeType":"VariableDeclaration","scope":8265,"src":"5879:16:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8195,"name":"uint256","nodeType":"ElementaryTypeName","src":"5879:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"5803:98:20"},"returnParameters":{"id":8199,"nodeType":"ParameterList","parameters":[],"src":"5920:0:20"},"scope":8650,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":8294,"nodeType":"FunctionDefinition","src":"6652:291:20","nodes":[],"body":{"id":8293,"nodeType":"Block","src":"6804:139:20","nodes":[],"statements":[{"condition":{"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":8281,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"expression":{"id":8278,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"6818:3:20","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":8279,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"6822:6:20","memberName":"sender","nodeType":"MemberAccess","src":"6818:10:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"id":8280,"name":"pool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8268,"src":"6832:4:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"src":"6818:18:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":8285,"nodeType":"IfStatement","src":"6814:59:20","trueBody":{"errorCall":{"arguments":[],"expression":{"argumentTypes":[],"id":8282,"name":"LunarLpFeeManager__NotPool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":22010,"src":"6845:26:20","typeDescriptions":{"typeIdentifier":"t_function_error_pure$__$returns$_t_error_$","typeString":"function () pure returns (error)"}},"id":8283,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6845:28:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_error","typeString":"error"}},"id":8284,"nodeType":"RevertStatement","src":"6838:35:20"}},{"expression":{"arguments":[{"id":8287,"name":"pool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8268,"src":"6898:4:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":8288,"name":"account","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8270,"src":"6904:7:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":8289,"name":"oldBalance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8272,"src":"6913:10:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":8290,"name":"newBalance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8274,"src":"6925:10:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":8286,"name":"_updateAccount","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8649,"src":"6883:14:20","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_address_$_t_address_$_t_uint256_$_t_uint256_$returns$__$","typeString":"function (address,address,uint256,uint256)"}},"id":8291,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"6883:53:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":8292,"nodeType":"ExpressionStatement","src":"6883:53:20"}]},"baseFunctions":[22568],"documentation":{"id":8266,"nodeType":"StructuredDocumentation","src":"6347:300:20","text":"@notice Updates fee debts when an LP balance changes.\n @dev Only callable by the pool whose balances changed.\n @param pool Pool address.\n @param account LP account whose balance changed.\n @param oldBalance Previous LP balance.\n @param newBalance New LP balance."},"functionSelector":"ed4609d7","implemented":true,"kind":"function","modifiers":[],"name":"onBalanceChange","nameLocation":"6661:15:20","overrides":{"id":8276,"nodeType":"OverrideSpecifier","overrides":[],"src":"6795:8:20"},"parameters":{"id":8275,"nodeType":"ParameterList","parameters":[{"constant":false,"id":8268,"mutability":"mutable","name":"pool","nameLocation":"6694:4:20","nodeType":"VariableDeclaration","scope":8294,"src":"6686:12:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8267,"name":"address","nodeType":"ElementaryTypeName","src":"6686:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":8270,"mutability":"mutable","name":"account","nameLocation":"6716:7:20","nodeType":"VariableDeclaration","scope":8294,"src":"6708:15:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8269,"name":"address","nodeType":"ElementaryTypeName","src":"6708:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":8272,"mutability":"mutable","name":"oldBalance","nameLocation":"6741:10:20","nodeType":"VariableDeclaration","scope":8294,"src":"6733:18:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8271,"name":"uint256","nodeType":"ElementaryTypeName","src":"6733:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":8274,"mutability":"mutable","name":"newBalance","nameLocation":"6769:10:20","nodeType":"VariableDeclaration","scope":8294,"src":"6761:18:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8273,"name":"uint256","nodeType":"ElementaryTypeName","src":"6761:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"6676:109:20"},"returnParameters":{"id":8277,"nodeType":"ParameterList","parameters":[],"src":"6804:0:20"},"scope":8650,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":8440,"nodeType":"FunctionDefinition","src":"7192:1030:20","nodes":[],"body":{"id":8439,"nodeType":"Block","src":"7323:899:20","nodes":[],"statements":[{"condition":{"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":8314,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8309,"name":"to","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8299,"src":"7337:2:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"arguments":[{"hexValue":"30","id":8312,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"7351:1:20","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":8311,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"7343:7:20","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":8310,"name":"address","nodeType":"ElementaryTypeName","src":"7343:7:20","typeDescriptions":{}}},"id":8313,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"7343:10:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"src":"7337:16:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":8318,"nodeType":"IfStatement","src":"7333:61:20","trueBody":{"errorCall":{"arguments":[],"expression":{"argumentTypes":[],"id":8315,"name":"LunarLpFeeManager__ZeroAddress","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":22012,"src":"7362:30:20","typeDescriptions":{"typeIdentifier":"t_function_error_pure$__$returns$_t_error_$","typeString":"function () pure returns (error)"}},"id":8316,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"7362:32:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_error","typeString":"error"}},"id":8317,"nodeType":"RevertStatement","src":"7355:39:20"}},{"assignments":[8321],"declarations":[{"constant":false,"id":8321,"mutability":"mutable","name":"source","nameLocation":"7422:6:20","nodeType":"VariableDeclaration","scope":8439,"src":"7404:24:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_ILunarLpFeeSource_$8123","typeString":"contract ILunarLpFeeSource"},"typeName":{"id":8320,"nodeType":"UserDefinedTypeName","pathNode":{"id":8319,"name":"ILunarLpFeeSource","nameLocations":["7404:17:20"],"nodeType":"IdentifierPath","referencedDeclaration":8123,"src":"7404:17:20"},"referencedDeclaration":8123,"src":"7404:17:20","typeDescriptions":{"typeIdentifier":"t_contract$_ILunarLpFeeSource_$8123","typeString":"contract ILunarLpFeeSource"}},"visibility":"internal"}],"id":8325,"initialValue":{"arguments":[{"id":8323,"name":"pool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8297,"src":"7449:4:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":8322,"name":"ILunarLpFeeSource","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8123,"src":"7431:17:20","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_ILunarLpFeeSource_$8123_$","typeString":"type(contract ILunarLpFeeSource)"}},"id":8324,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"7431:23:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_ILunarLpFeeSource_$8123","typeString":"contract ILunarLpFeeSource"}},"nodeType":"VariableDeclarationStatement","src":"7404:50:20"},{"assignments":[8327],"declarations":[{"constant":false,"id":8327,"mutability":"mutable","name":"balance","nameLocation":"7472:7:20","nodeType":"VariableDeclaration","scope":8439,"src":"7464:15:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8326,"name":"uint256","nodeType":"ElementaryTypeName","src":"7464:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":8333,"initialValue":{"arguments":[{"expression":{"id":8330,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"7499:3:20","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":8331,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"7503:6:20","memberName":"sender","nodeType":"MemberAccess","src":"7499:10:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":8328,"name":"source","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8321,"src":"7482:6:20","typeDescriptions":{"typeIdentifier":"t_contract$_ILunarLpFeeSource_$8123","typeString":"contract ILunarLpFeeSource"}},"id":8329,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"7489:9:20","memberName":"balanceOf","nodeType":"MemberAccess","referencedDeclaration":8108,"src":"7482:16:20","typeDescriptions":{"typeIdentifier":"t_function_external_view$_t_address_$returns$_t_uint256_$","typeString":"function (address) view external returns (uint256)"}},"id":8332,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"7482:28:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"VariableDeclarationStatement","src":"7464:46:20"},{"expression":{"arguments":[{"id":8335,"name":"pool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8297,"src":"7535:4:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"expression":{"id":8336,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"7541:3:20","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":8337,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"7545:6:20","memberName":"sender","nodeType":"MemberAccess","src":"7541:10:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":8338,"name":"balance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8327,"src":"7553:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":8339,"name":"balance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8327,"src":"7562:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":8334,"name":"_updateAccount","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8649,"src":"7520:14:20","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_address_$_t_address_$_t_uint256_$_t_uint256_$returns$__$","typeString":"function (address,address,uint256,uint256)"}},"id":8340,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"7520:50:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":8341,"nodeType":"ExpressionStatement","src":"7520:50:20"},{"assignments":[8344],"declarations":[{"constant":false,"id":8344,"mutability":"mutable","name":"st","nameLocation":"7602:2:20","nodeType":"VariableDeclaration","scope":8439,"src":"7581:23:20","stateVariable":false,"storageLocation":"storage","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState"},"typeName":{"id":8343,"nodeType":"UserDefinedTypeName","pathNode":{"id":8342,"name":"AccountState","nameLocations":["7581:12:20"],"nodeType":"IdentifierPath","referencedDeclaration":8145,"src":"7581:12:20"},"referencedDeclaration":8145,"src":"7581:12:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState"}},"visibility":"internal"}],"id":8351,"initialValue":{"baseExpression":{"baseExpression":{"id":8345,"name":"accountState","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8157,"src":"7607:12:20","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_struct$_AccountState_$8145_storage_$_$","typeString":"mapping(address => mapping(address => struct LunarLpFeeManager.AccountState storage ref))"}},"id":8347,"indexExpression":{"id":8346,"name":"pool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8297,"src":"7620:4:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"7607:18:20","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_struct$_AccountState_$8145_storage_$","typeString":"mapping(address => struct LunarLpFeeManager.AccountState storage ref)"}},"id":8350,"indexExpression":{"expression":{"id":8348,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"7626:3:20","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":8349,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"7630:6:20","memberName":"sender","nodeType":"MemberAccess","src":"7626:10:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"7607:30:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage","typeString":"struct LunarLpFeeManager.AccountState storage ref"}},"nodeType":"VariableDeclarationStatement","src":"7581:56:20"},{"expression":{"id":8355,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":8352,"name":"fee0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8305,"src":"7647:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"expression":{"id":8353,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8344,"src":"7654:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8354,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"7657:11:20","memberName":"fee0Accrued","nodeType":"MemberAccess","referencedDeclaration":8142,"src":"7654:14:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"7647:21:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8356,"nodeType":"ExpressionStatement","src":"7647:21:20"},{"expression":{"id":8360,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":8357,"name":"fee1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8307,"src":"7678:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"expression":{"id":8358,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8344,"src":"7685:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8359,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"7688:11:20","memberName":"fee1Accrued","nodeType":"MemberAccess","referencedDeclaration":8144,"src":"7685:14:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"7678:21:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8361,"nodeType":"ExpressionStatement","src":"7678:21:20"},{"condition":{"commonType":{"typeIdentifier":"t_bool","typeString":"bool"},"id":8368,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8364,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8362,"name":"fee0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8305,"src":"7713:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"hexValue":"30","id":8363,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"7721:1:20","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"7713:9:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"nodeType":"BinaryOperation","operator":"&&","rightExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8367,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8365,"name":"fee1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8307,"src":"7726:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"hexValue":"30","id":8366,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"7734:1:20","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"7726:9:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"src":"7713:22:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":8372,"nodeType":"IfStatement","src":"7709:70:20","trueBody":{"errorCall":{"arguments":[],"expression":{"argumentTypes":[],"id":8369,"name":"LunarLpFeeManager__NothingToClaim","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":22014,"src":"7744:33:20","typeDescriptions":{"typeIdentifier":"t_function_error_pure$__$returns$_t_error_$","typeString":"function () pure returns (error)"}},"id":8370,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"7744:35:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_error","typeString":"error"}},"id":8371,"nodeType":"RevertStatement","src":"7737:42:20"}},{"condition":{"commonType":{"typeIdentifier":"t_bool","typeString":"bool"},"id":8387,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8379,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8373,"name":"fee0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8305,"src":"7793:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"expression":{"arguments":[{"id":8376,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"7805:7:20","typeDescriptions":{"typeIdentifier":"t_type$_t_uint128_$","typeString":"type(uint128)"},"typeName":{"id":8375,"name":"uint128","nodeType":"ElementaryTypeName","src":"7805:7:20","typeDescriptions":{}}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_type$_t_uint128_$","typeString":"type(uint128)"}],"id":8374,"name":"type","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-27,"src":"7800:4:20","typeDescriptions":{"typeIdentifier":"t_function_metatype_pure$__$returns$__$","typeString":"function () pure"}},"id":8377,"isConstant":false,"isLValue":false,"isPure":true,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"7800:13:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_magic_meta_type_t_uint128","typeString":"type(uint128)"}},"id":8378,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"7814:3:20","memberName":"max","nodeType":"MemberAccess","src":"7800:17:20","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"}},"src":"7793:24:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"nodeType":"BinaryOperation","operator":"||","rightExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8386,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8380,"name":"fee1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8307,"src":"7821:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"expression":{"arguments":[{"id":8383,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"7833:7:20","typeDescriptions":{"typeIdentifier":"t_type$_t_uint128_$","typeString":"type(uint128)"},"typeName":{"id":8382,"name":"uint128","nodeType":"ElementaryTypeName","src":"7833:7:20","typeDescriptions":{}}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_type$_t_uint128_$","typeString":"type(uint128)"}],"id":8381,"name":"type","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-27,"src":"7828:4:20","typeDescriptions":{"typeIdentifier":"t_function_metatype_pure$__$returns$__$","typeString":"function () pure"}},"id":8384,"isConstant":false,"isLValue":false,"isPure":true,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"7828:13:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_magic_meta_type_t_uint128","typeString":"type(uint128)"}},"id":8385,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"7842:3:20","memberName":"max","nodeType":"MemberAccess","src":"7828:17:20","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"}},"src":"7821:24:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"src":"7793:52:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":8392,"nodeType":"IfStatement","src":"7789:125:20","trueBody":{"id":8391,"nodeType":"Block","src":"7847:67:20","statements":[{"errorCall":{"arguments":[],"expression":{"argumentTypes":[],"id":8388,"name":"LunarLpFeeManager__AmountTooLarge","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":22016,"src":"7868:33:20","typeDescriptions":{"typeIdentifier":"t_function_error_pure$__$returns$_t_error_$","typeString":"function () pure returns (error)"}},"id":8389,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"7868:35:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_error","typeString":"error"}},"id":8390,"nodeType":"RevertStatement","src":"7861:42:20"}]}},{"expression":{"id":8397,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"expression":{"id":8393,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8344,"src":"7923:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8395,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"memberLocation":"7926:11:20","memberName":"fee0Accrued","nodeType":"MemberAccess","referencedDeclaration":8142,"src":"7923:14:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"hexValue":"30","id":8396,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"7940:1:20","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"7923:18:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8398,"nodeType":"ExpressionStatement","src":"7923:18:20"},{"expression":{"id":8403,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"expression":{"id":8399,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8344,"src":"7951:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8401,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"memberLocation":"7954:11:20","memberName":"fee1Accrued","nodeType":"MemberAccess","referencedDeclaration":8144,"src":"7951:14:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"hexValue":"30","id":8402,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"7968:1:20","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"src":"7951:18:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8404,"nodeType":"ExpressionStatement","src":"7951:18:20"},{"assignments":[8406,8408],"declarations":[{"constant":false,"id":8406,"mutability":"mutable","name":"paid0","nameLocation":"7989:5:20","nodeType":"VariableDeclaration","scope":8439,"src":"7981:13:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"},"typeName":{"id":8405,"name":"uint128","nodeType":"ElementaryTypeName","src":"7981:7:20","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"}},"visibility":"internal"},{"constant":false,"id":8408,"mutability":"mutable","name":"paid1","nameLocation":"8004:5:20","nodeType":"VariableDeclaration","scope":8439,"src":"7996:13:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"},"typeName":{"id":8407,"name":"uint128","nodeType":"ElementaryTypeName","src":"7996:7:20","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"}},"visibility":"internal"}],"id":8421,"initialValue":{"arguments":[{"id":8411,"name":"to","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8299,"src":"8045:2:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"arguments":[{"id":8414,"name":"fee0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8305,"src":"8069:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":8413,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"8061:7:20","typeDescriptions":{"typeIdentifier":"t_type$_t_uint128_$","typeString":"type(uint128)"},"typeName":{"id":8412,"name":"uint128","nodeType":"ElementaryTypeName","src":"8061:7:20","typeDescriptions":{}}},"id":8415,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"8061:13:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"}},{"arguments":[{"id":8418,"name":"fee1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8307,"src":"8096:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":8417,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"8088:7:20","typeDescriptions":{"typeIdentifier":"t_type$_t_uint128_$","typeString":"type(uint128)"},"typeName":{"id":8416,"name":"uint128","nodeType":"ElementaryTypeName","src":"8088:7:20","typeDescriptions":{}}},"id":8419,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"8088:13:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint128","typeString":"uint128"},{"typeIdentifier":"t_uint128","typeString":"uint128"}],"expression":{"id":8409,"name":"source","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8321,"src":"8013:6:20","typeDescriptions":{"typeIdentifier":"t_contract$_ILunarLpFeeSource_$8123","typeString":"contract ILunarLpFeeSource"}},"id":8410,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"8020:11:20","memberName":"collectFees","nodeType":"MemberAccess","referencedDeclaration":8122,"src":"8013:18:20","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$_t_address_$_t_uint128_$_t_uint128_$returns$_t_uint128_$_t_uint128_$","typeString":"function (address,uint128,uint128) external returns (uint128,uint128)"}},"id":8420,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"8013:98:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$_t_uint128_$_t_uint128_$","typeString":"tuple(uint128,uint128)"}},"nodeType":"VariableDeclarationStatement","src":"7980:131:20"},{"expression":{"id":8424,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":8422,"name":"fee0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8305,"src":"8121:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"id":8423,"name":"paid0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8406,"src":"8128:5:20","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"}},"src":"8121:12:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8425,"nodeType":"ExpressionStatement","src":"8121:12:20"},{"expression":{"id":8428,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":8426,"name":"fee1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8307,"src":"8143:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"id":8427,"name":"paid1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8408,"src":"8150:5:20","typeDescriptions":{"typeIdentifier":"t_uint128","typeString":"uint128"}},"src":"8143:12:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8429,"nodeType":"ExpressionStatement","src":"8143:12:20"},{"eventCall":{"arguments":[{"id":8431,"name":"pool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8297,"src":"8182:4:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"expression":{"id":8432,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"8188:3:20","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":8433,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"8192:6:20","memberName":"sender","nodeType":"MemberAccess","src":"8188:10:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":8434,"name":"to","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8299,"src":"8200:2:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":8435,"name":"fee0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8305,"src":"8204:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":8436,"name":"fee1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8307,"src":"8210:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":8430,"name":"FeesClaimed","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8187,"src":"8170:11:20","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_address_$_t_address_$_t_address_$_t_uint256_$_t_uint256_$returns$__$","typeString":"function (address,address,address,uint256,uint256)"}},"id":8437,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"8170:45:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":8438,"nodeType":"EmitStatement","src":"8165:50:20"}]},"baseFunctions":[22580],"documentation":{"id":8295,"nodeType":"StructuredDocumentation","src":"6949:238:20","text":"@notice Claims accrued fees for the caller from a pool.\n @param pool Pool address.\n @param to Recipient of the fee payout.\n @return fee0 Amount of token0 fees paid.\n @return fee1 Amount of token1 fees paid."},"functionSelector":"21c0b342","implemented":true,"kind":"function","modifiers":[{"id":8303,"kind":"modifierInvocation","modifierName":{"id":8302,"name":"nonReentrant","nameLocations":["7273:12:20"],"nodeType":"IdentifierPath","referencedDeclaration":1175,"src":"7273:12:20"},"nodeType":"ModifierInvocation","src":"7273:12:20"}],"name":"claim","nameLocation":"7201:5:20","overrides":{"id":8301,"nodeType":"OverrideSpecifier","overrides":[],"src":"7264:8:20"},"parameters":{"id":8300,"nodeType":"ParameterList","parameters":[{"constant":false,"id":8297,"mutability":"mutable","name":"pool","nameLocation":"7224:4:20","nodeType":"VariableDeclaration","scope":8440,"src":"7216:12:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8296,"name":"address","nodeType":"ElementaryTypeName","src":"7216:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":8299,"mutability":"mutable","name":"to","nameLocation":"7246:2:20","nodeType":"VariableDeclaration","scope":8440,"src":"7238:10:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8298,"name":"address","nodeType":"ElementaryTypeName","src":"7238:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"7206:48:20"},"returnParameters":{"id":8308,"nodeType":"ParameterList","parameters":[{"constant":false,"id":8305,"mutability":"mutable","name":"fee0","nameLocation":"7303:4:20","nodeType":"VariableDeclaration","scope":8440,"src":"7295:12:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8304,"name":"uint256","nodeType":"ElementaryTypeName","src":"7295:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":8307,"mutability":"mutable","name":"fee1","nameLocation":"7317:4:20","nodeType":"VariableDeclaration","scope":8440,"src":"7309:12:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8306,"name":"uint256","nodeType":"ElementaryTypeName","src":"7309:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"7294:28:20"},"scope":8650,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":8533,"nodeType":"FunctionDefinition","src":"8477:676:20","nodes":[],"body":{"id":8532,"nodeType":"Block","src":"8607:546:20","nodes":[],"statements":[{"assignments":[8455],"declarations":[{"constant":false,"id":8455,"mutability":"mutable","name":"st","nameLocation":"8638:2:20","nodeType":"VariableDeclaration","scope":8532,"src":"8617:23:20","stateVariable":false,"storageLocation":"storage","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState"},"typeName":{"id":8454,"nodeType":"UserDefinedTypeName","pathNode":{"id":8453,"name":"AccountState","nameLocations":["8617:12:20"],"nodeType":"IdentifierPath","referencedDeclaration":8145,"src":"8617:12:20"},"referencedDeclaration":8145,"src":"8617:12:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState"}},"visibility":"internal"}],"id":8461,"initialValue":{"baseExpression":{"baseExpression":{"id":8456,"name":"accountState","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8157,"src":"8643:12:20","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_struct$_AccountState_$8145_storage_$_$","typeString":"mapping(address => mapping(address => struct LunarLpFeeManager.AccountState storage ref))"}},"id":8458,"indexExpression":{"id":8457,"name":"pool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8443,"src":"8656:4:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"8643:18:20","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_struct$_AccountState_$8145_storage_$","typeString":"mapping(address => struct LunarLpFeeManager.AccountState storage ref)"}},"id":8460,"indexExpression":{"id":8459,"name":"account","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8445,"src":"8662:7:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"8643:27:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage","typeString":"struct LunarLpFeeManager.AccountState storage ref"}},"nodeType":"VariableDeclarationStatement","src":"8617:53:20"},{"assignments":[8464],"declarations":[{"constant":false,"id":8464,"mutability":"mutable","name":"ps","nameLocation":"8698:2:20","nodeType":"VariableDeclaration","scope":8532,"src":"8680:20:20","stateVariable":false,"storageLocation":"storage","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage_ptr","typeString":"struct LunarLpFeeManager.PoolState"},"typeName":{"id":8463,"nodeType":"UserDefinedTypeName","pathNode":{"id":8462,"name":"PoolState","nameLocations":["8680:9:20"],"nodeType":"IdentifierPath","referencedDeclaration":8136,"src":"8680:9:20"},"referencedDeclaration":8136,"src":"8680:9:20","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage_ptr","typeString":"struct LunarLpFeeManager.PoolState"}},"visibility":"internal"}],"id":8468,"initialValue":{"baseExpression":{"id":8465,"name":"poolState","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8150,"src":"8703:9:20","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_struct$_PoolState_$8136_storage_$","typeString":"mapping(address => struct LunarLpFeeManager.PoolState storage ref)"}},"id":8467,"indexExpression":{"id":8466,"name":"pool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8443,"src":"8713:4:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"8703:15:20","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage","typeString":"struct LunarLpFeeManager.PoolState storage ref"}},"nodeType":"VariableDeclarationStatement","src":"8680:38:20"},{"assignments":[8470],"declarations":[{"constant":false,"id":8470,"mutability":"mutable","name":"balance","nameLocation":"8736:7:20","nodeType":"VariableDeclaration","scope":8532,"src":"8728:15:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8469,"name":"uint256","nodeType":"ElementaryTypeName","src":"8728:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":8477,"initialValue":{"arguments":[{"id":8475,"name":"account","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8445,"src":"8780:7:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"arguments":[{"id":8472,"name":"pool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8443,"src":"8764:4:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":8471,"name":"ILunarLpFeeSource","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8123,"src":"8746:17:20","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_ILunarLpFeeSource_$8123_$","typeString":"type(contract ILunarLpFeeSource)"}},"id":8473,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"8746:23:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_ILunarLpFeeSource_$8123","typeString":"contract ILunarLpFeeSource"}},"id":8474,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"8770:9:20","memberName":"balanceOf","nodeType":"MemberAccess","referencedDeclaration":8108,"src":"8746:33:20","typeDescriptions":{"typeIdentifier":"t_function_external_view$_t_address_$returns$_t_uint256_$","typeString":"function (address) view external returns (uint256)"}},"id":8476,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"8746:42:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"VariableDeclarationStatement","src":"8728:60:20"},{"assignments":[8479],"declarations":[{"constant":false,"id":8479,"mutability":"mutable","name":"accrued0","nameLocation":"8806:8:20","nodeType":"VariableDeclaration","scope":8532,"src":"8798:16:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8478,"name":"uint256","nodeType":"ElementaryTypeName","src":"8798:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":8487,"initialValue":{"arguments":[{"id":8482,"name":"balance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8470,"src":"8829:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"expression":{"id":8483,"name":"ps","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8464,"src":"8838:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage_ptr","typeString":"struct LunarLpFeeManager.PoolState storage pointer"}},"id":8484,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"8841:15:20","memberName":"accFee0PerShare","nodeType":"MemberAccess","referencedDeclaration":8133,"src":"8838:18:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":8485,"name":"ACC_SCALE","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8131,"src":"8858:9:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"expression":{"id":8480,"name":"Math","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":3318,"src":"8817:4:20","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Math_$3318_$","typeString":"type(library Math)"}},"id":8481,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"8822:6:20","memberName":"mulDiv","nodeType":"MemberAccess","referencedDeclaration":2189,"src":"8817:11:20","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$returns$_t_uint256_$","typeString":"function (uint256,uint256,uint256) pure returns (uint256)"}},"id":8486,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"8817:51:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"VariableDeclarationStatement","src":"8798:70:20"},{"assignments":[8489],"declarations":[{"constant":false,"id":8489,"mutability":"mutable","name":"accrued1","nameLocation":"8886:8:20","nodeType":"VariableDeclaration","scope":8532,"src":"8878:16:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8488,"name":"uint256","nodeType":"ElementaryTypeName","src":"8878:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":8497,"initialValue":{"arguments":[{"id":8492,"name":"balance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8470,"src":"8909:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"expression":{"id":8493,"name":"ps","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8464,"src":"8918:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage_ptr","typeString":"struct LunarLpFeeManager.PoolState storage pointer"}},"id":8494,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"8921:15:20","memberName":"accFee1PerShare","nodeType":"MemberAccess","referencedDeclaration":8135,"src":"8918:18:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":8495,"name":"ACC_SCALE","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8131,"src":"8938:9:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"expression":{"id":8490,"name":"Math","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":3318,"src":"8897:4:20","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Math_$3318_$","typeString":"type(library Math)"}},"id":8491,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"8902:6:20","memberName":"mulDiv","nodeType":"MemberAccess","referencedDeclaration":2189,"src":"8897:11:20","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$returns$_t_uint256_$","typeString":"function (uint256,uint256,uint256) pure returns (uint256)"}},"id":8496,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"8897:51:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"VariableDeclarationStatement","src":"8878:70:20"},{"expression":{"id":8501,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":8498,"name":"fee0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8449,"src":"8958:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"expression":{"id":8499,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8455,"src":"8965:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8500,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"8968:11:20","memberName":"fee0Accrued","nodeType":"MemberAccess","referencedDeclaration":8142,"src":"8965:14:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"8958:21:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8502,"nodeType":"ExpressionStatement","src":"8958:21:20"},{"expression":{"id":8506,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":8503,"name":"fee1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8451,"src":"8989:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"expression":{"id":8504,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8455,"src":"8996:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8505,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"8999:11:20","memberName":"fee1Accrued","nodeType":"MemberAccess","referencedDeclaration":8144,"src":"8996:14:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"8989:21:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8507,"nodeType":"ExpressionStatement","src":"8989:21:20"},{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8511,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8508,"name":"accrued0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8479,"src":"9024:8:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"expression":{"id":8509,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8455,"src":"9035:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8510,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"9038:8:20","memberName":"fee0Debt","nodeType":"MemberAccess","referencedDeclaration":8138,"src":"9035:11:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"9024:22:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":8519,"nodeType":"IfStatement","src":"9020:58:20","trueBody":{"expression":{"id":8517,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":8512,"name":"fee0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8449,"src":"9048:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"+=","rightHandSide":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8516,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8513,"name":"accrued0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8479,"src":"9056:8:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"-","rightExpression":{"expression":{"id":8514,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8455,"src":"9067:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8515,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"9070:8:20","memberName":"fee0Debt","nodeType":"MemberAccess","referencedDeclaration":8138,"src":"9067:11:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"9056:22:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"9048:30:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8518,"nodeType":"ExpressionStatement","src":"9048:30:20"}},{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8523,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8520,"name":"accrued1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8489,"src":"9092:8:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"expression":{"id":8521,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8455,"src":"9103:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8522,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"9106:8:20","memberName":"fee1Debt","nodeType":"MemberAccess","referencedDeclaration":8140,"src":"9103:11:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"9092:22:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":8531,"nodeType":"IfStatement","src":"9088:58:20","trueBody":{"expression":{"id":8529,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":8524,"name":"fee1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8451,"src":"9116:4:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"+=","rightHandSide":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8528,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8525,"name":"accrued1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8489,"src":"9124:8:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"-","rightExpression":{"expression":{"id":8526,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8455,"src":"9135:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8527,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"9138:8:20","memberName":"fee1Debt","nodeType":"MemberAccess","referencedDeclaration":8140,"src":"9135:11:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"9124:22:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"9116:30:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8530,"nodeType":"ExpressionStatement","src":"9116:30:20"}}]},"baseFunctions":[22592],"documentation":{"id":8441,"nodeType":"StructuredDocumentation","src":"8228:244:20","text":"@notice Previews the claimable fees for an account without modifying state.\n @param pool Pool address.\n @param account Account to preview.\n @return fee0 Claimable token0 fees.\n @return fee1 Claimable token1 fees."},"functionSelector":"15023365","implemented":true,"kind":"function","modifiers":[],"name":"preview","nameLocation":"8486:7:20","overrides":{"id":8447,"nodeType":"OverrideSpecifier","overrides":[],"src":"8561:8:20"},"parameters":{"id":8446,"nodeType":"ParameterList","parameters":[{"constant":false,"id":8443,"mutability":"mutable","name":"pool","nameLocation":"8511:4:20","nodeType":"VariableDeclaration","scope":8533,"src":"8503:12:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8442,"name":"address","nodeType":"ElementaryTypeName","src":"8503:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":8445,"mutability":"mutable","name":"account","nameLocation":"8533:7:20","nodeType":"VariableDeclaration","scope":8533,"src":"8525:15:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8444,"name":"address","nodeType":"ElementaryTypeName","src":"8525:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"8493:53:20"},"returnParameters":{"id":8452,"nodeType":"ParameterList","parameters":[{"constant":false,"id":8449,"mutability":"mutable","name":"fee0","nameLocation":"8587:4:20","nodeType":"VariableDeclaration","scope":8533,"src":"8579:12:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8448,"name":"uint256","nodeType":"ElementaryTypeName","src":"8579:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":8451,"mutability":"mutable","name":"fee1","nameLocation":"8601:4:20","nodeType":"VariableDeclaration","scope":8533,"src":"8593:12:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8450,"name":"uint256","nodeType":"ElementaryTypeName","src":"8593:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"8578:28:20"},"scope":8650,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":8649,"nodeType":"FunctionDefinition","src":"9401:941:20","nodes":[],"body":{"id":8648,"nodeType":"Block","src":"9543:799:20","nodes":[],"statements":[{"condition":{"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":8550,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8545,"name":"account","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8538,"src":"9557:7:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"arguments":[{"hexValue":"30","id":8548,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"9576:1:20","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":8547,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"9568:7:20","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":8546,"name":"address","nodeType":"ElementaryTypeName","src":"9568:7:20","typeDescriptions":{}}},"id":8549,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"9568:10:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"src":"9557:21:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":8552,"nodeType":"IfStatement","src":"9553:34:20","trueBody":{"functionReturnParameters":8544,"id":8551,"nodeType":"Return","src":"9580:7:20"}},{"assignments":[8555],"declarations":[{"constant":false,"id":8555,"mutability":"mutable","name":"ps","nameLocation":"9614:2:20","nodeType":"VariableDeclaration","scope":8648,"src":"9596:20:20","stateVariable":false,"storageLocation":"storage","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage_ptr","typeString":"struct LunarLpFeeManager.PoolState"},"typeName":{"id":8554,"nodeType":"UserDefinedTypeName","pathNode":{"id":8553,"name":"PoolState","nameLocations":["9596:9:20"],"nodeType":"IdentifierPath","referencedDeclaration":8136,"src":"9596:9:20"},"referencedDeclaration":8136,"src":"9596:9:20","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage_ptr","typeString":"struct LunarLpFeeManager.PoolState"}},"visibility":"internal"}],"id":8559,"initialValue":{"baseExpression":{"id":8556,"name":"poolState","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8150,"src":"9619:9:20","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_struct$_PoolState_$8136_storage_$","typeString":"mapping(address => struct LunarLpFeeManager.PoolState storage ref)"}},"id":8558,"indexExpression":{"id":8557,"name":"pool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8536,"src":"9629:4:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"9619:15:20","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage","typeString":"struct LunarLpFeeManager.PoolState storage ref"}},"nodeType":"VariableDeclarationStatement","src":"9596:38:20"},{"assignments":[8562],"declarations":[{"constant":false,"id":8562,"mutability":"mutable","name":"st","nameLocation":"9665:2:20","nodeType":"VariableDeclaration","scope":8648,"src":"9644:23:20","stateVariable":false,"storageLocation":"storage","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState"},"typeName":{"id":8561,"nodeType":"UserDefinedTypeName","pathNode":{"id":8560,"name":"AccountState","nameLocations":["9644:12:20"],"nodeType":"IdentifierPath","referencedDeclaration":8145,"src":"9644:12:20"},"referencedDeclaration":8145,"src":"9644:12:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState"}},"visibility":"internal"}],"id":8568,"initialValue":{"baseExpression":{"baseExpression":{"id":8563,"name":"accountState","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8157,"src":"9670:12:20","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_struct$_AccountState_$8145_storage_$_$","typeString":"mapping(address => mapping(address => struct LunarLpFeeManager.AccountState storage ref))"}},"id":8565,"indexExpression":{"id":8564,"name":"pool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8536,"src":"9683:4:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"9670:18:20","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_struct$_AccountState_$8145_storage_$","typeString":"mapping(address => struct LunarLpFeeManager.AccountState storage ref)"}},"id":8567,"indexExpression":{"id":8566,"name":"account","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8538,"src":"9689:7:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"9670:27:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage","typeString":"struct LunarLpFeeManager.AccountState storage ref"}},"nodeType":"VariableDeclarationStatement","src":"9644:53:20"},{"assignments":[8570],"declarations":[{"constant":false,"id":8570,"mutability":"mutable","name":"accrued0","nameLocation":"9715:8:20","nodeType":"VariableDeclaration","scope":8648,"src":"9707:16:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8569,"name":"uint256","nodeType":"ElementaryTypeName","src":"9707:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":8578,"initialValue":{"arguments":[{"id":8573,"name":"oldBalance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8540,"src":"9751:10:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"expression":{"id":8574,"name":"ps","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8555,"src":"9775:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage_ptr","typeString":"struct LunarLpFeeManager.PoolState storage pointer"}},"id":8575,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"9778:15:20","memberName":"accFee0PerShare","nodeType":"MemberAccess","referencedDeclaration":8133,"src":"9775:18:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":8576,"name":"ACC_SCALE","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8131,"src":"9807:9:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"expression":{"id":8571,"name":"Math","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":3318,"src":"9726:4:20","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Math_$3318_$","typeString":"type(library Math)"}},"id":8572,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"9731:6:20","memberName":"mulDiv","nodeType":"MemberAccess","referencedDeclaration":2189,"src":"9726:11:20","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$returns$_t_uint256_$","typeString":"function (uint256,uint256,uint256) pure returns (uint256)"}},"id":8577,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"9726:100:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"VariableDeclarationStatement","src":"9707:119:20"},{"assignments":[8580],"declarations":[{"constant":false,"id":8580,"mutability":"mutable","name":"accrued1","nameLocation":"9844:8:20","nodeType":"VariableDeclaration","scope":8648,"src":"9836:16:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8579,"name":"uint256","nodeType":"ElementaryTypeName","src":"9836:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":8588,"initialValue":{"arguments":[{"id":8583,"name":"oldBalance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8540,"src":"9880:10:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"expression":{"id":8584,"name":"ps","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8555,"src":"9904:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage_ptr","typeString":"struct LunarLpFeeManager.PoolState storage pointer"}},"id":8585,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"9907:15:20","memberName":"accFee1PerShare","nodeType":"MemberAccess","referencedDeclaration":8135,"src":"9904:18:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":8586,"name":"ACC_SCALE","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8131,"src":"9936:9:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"expression":{"id":8581,"name":"Math","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":3318,"src":"9855:4:20","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Math_$3318_$","typeString":"type(library Math)"}},"id":8582,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"9860:6:20","memberName":"mulDiv","nodeType":"MemberAccess","referencedDeclaration":2189,"src":"9855:11:20","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$returns$_t_uint256_$","typeString":"function (uint256,uint256,uint256) pure returns (uint256)"}},"id":8587,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"9855:100:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"VariableDeclarationStatement","src":"9836:119:20"},{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8592,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8589,"name":"accrued0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8570,"src":"9969:8:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"expression":{"id":8590,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8562,"src":"9980:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8591,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"9983:8:20","memberName":"fee0Debt","nodeType":"MemberAccess","referencedDeclaration":8138,"src":"9980:11:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"9969:22:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":8602,"nodeType":"IfStatement","src":"9965:68:20","trueBody":{"expression":{"id":8600,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"expression":{"id":8593,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8562,"src":"9993:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8595,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"memberLocation":"9996:11:20","memberName":"fee0Accrued","nodeType":"MemberAccess","referencedDeclaration":8142,"src":"9993:14:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"+=","rightHandSide":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8599,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8596,"name":"accrued0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8570,"src":"10011:8:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"-","rightExpression":{"expression":{"id":8597,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8562,"src":"10022:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8598,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"10025:8:20","memberName":"fee0Debt","nodeType":"MemberAccess","referencedDeclaration":8138,"src":"10022:11:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"10011:22:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"9993:40:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8601,"nodeType":"ExpressionStatement","src":"9993:40:20"}},{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8606,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8603,"name":"accrued1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8580,"src":"10047:8:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">","rightExpression":{"expression":{"id":8604,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8562,"src":"10058:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8605,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"10061:8:20","memberName":"fee1Debt","nodeType":"MemberAccess","referencedDeclaration":8140,"src":"10058:11:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"10047:22:20","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":8616,"nodeType":"IfStatement","src":"10043:68:20","trueBody":{"expression":{"id":8614,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"expression":{"id":8607,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8562,"src":"10071:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8609,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"memberLocation":"10074:11:20","memberName":"fee1Accrued","nodeType":"MemberAccess","referencedDeclaration":8144,"src":"10071:14:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"+=","rightHandSide":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":8613,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":8610,"name":"accrued1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8580,"src":"10089:8:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"-","rightExpression":{"expression":{"id":8611,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8562,"src":"10100:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8612,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"10103:8:20","memberName":"fee1Debt","nodeType":"MemberAccess","referencedDeclaration":8140,"src":"10100:11:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"10089:22:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"10071:40:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8615,"nodeType":"ExpressionStatement","src":"10071:40:20"}},{"expression":{"id":8627,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"expression":{"id":8617,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8562,"src":"10121:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8619,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"memberLocation":"10124:8:20","memberName":"fee0Debt","nodeType":"MemberAccess","referencedDeclaration":8138,"src":"10121:11:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"id":8622,"name":"newBalance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8542,"src":"10147:10:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"expression":{"id":8623,"name":"ps","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8555,"src":"10159:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage_ptr","typeString":"struct LunarLpFeeManager.PoolState storage pointer"}},"id":8624,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"10162:15:20","memberName":"accFee0PerShare","nodeType":"MemberAccess","referencedDeclaration":8133,"src":"10159:18:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":8625,"name":"ACC_SCALE","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8131,"src":"10179:9:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"expression":{"id":8620,"name":"Math","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":3318,"src":"10135:4:20","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Math_$3318_$","typeString":"type(library Math)"}},"id":8621,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"10140:6:20","memberName":"mulDiv","nodeType":"MemberAccess","referencedDeclaration":2189,"src":"10135:11:20","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$returns$_t_uint256_$","typeString":"function (uint256,uint256,uint256) pure returns (uint256)"}},"id":8626,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"10135:54:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"10121:68:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8628,"nodeType":"ExpressionStatement","src":"10121:68:20"},{"expression":{"id":8639,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"expression":{"id":8629,"name":"st","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8562,"src":"10199:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_AccountState_$8145_storage_ptr","typeString":"struct LunarLpFeeManager.AccountState storage pointer"}},"id":8631,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"memberLocation":"10202:8:20","memberName":"fee1Debt","nodeType":"MemberAccess","referencedDeclaration":8140,"src":"10199:11:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"arguments":[{"id":8634,"name":"newBalance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8542,"src":"10225:10:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"expression":{"id":8635,"name":"ps","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8555,"src":"10237:2:20","typeDescriptions":{"typeIdentifier":"t_struct$_PoolState_$8136_storage_ptr","typeString":"struct LunarLpFeeManager.PoolState storage pointer"}},"id":8636,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"10240:15:20","memberName":"accFee1PerShare","nodeType":"MemberAccess","referencedDeclaration":8135,"src":"10237:18:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":8637,"name":"ACC_SCALE","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8131,"src":"10257:9:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"expression":{"id":8632,"name":"Math","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":3318,"src":"10213:4:20","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Math_$3318_$","typeString":"type(library Math)"}},"id":8633,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"10218:6:20","memberName":"mulDiv","nodeType":"MemberAccess","referencedDeclaration":2189,"src":"10213:11:20","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$returns$_t_uint256_$","typeString":"function (uint256,uint256,uint256) pure returns (uint256)"}},"id":8638,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"10213:54:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"10199:68:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":8640,"nodeType":"ExpressionStatement","src":"10199:68:20"},{"eventCall":{"arguments":[{"id":8642,"name":"pool","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8536,"src":"10297:4:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":8643,"name":"account","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8538,"src":"10303:7:20","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":8644,"name":"oldBalance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8540,"src":"10312:10:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":8645,"name":"newBalance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8542,"src":"10324:10:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":8641,"name":"AccountUpdated","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":8175,"src":"10282:14:20","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_address_$_t_address_$_t_uint256_$_t_uint256_$returns$__$","typeString":"function (address,address,uint256,uint256)"}},"id":8646,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"10282:53:20","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":8647,"nodeType":"EmitStatement","src":"10277:58:20"}]},"documentation":{"id":8534,"nodeType":"StructuredDocumentation","src":"9159:237:20","text":"@notice Updates per-account fee accrual based on balance changes.\n @param pool Pool address.\n @param account LP account to update.\n @param oldBalance Previous LP balance.\n @param newBalance New LP balance."},"implemented":true,"kind":"function","modifiers":[],"name":"_updateAccount","nameLocation":"9410:14:20","parameters":{"id":8543,"nodeType":"ParameterList","parameters":[{"constant":false,"id":8536,"mutability":"mutable","name":"pool","nameLocation":"9442:4:20","nodeType":"VariableDeclaration","scope":8649,"src":"9434:12:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8535,"name":"address","nodeType":"ElementaryTypeName","src":"9434:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":8538,"mutability":"mutable","name":"account","nameLocation":"9464:7:20","nodeType":"VariableDeclaration","scope":8649,"src":"9456:15:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8537,"name":"address","nodeType":"ElementaryTypeName","src":"9456:7:20","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":8540,"mutability":"mutable","name":"oldBalance","nameLocation":"9489:10:20","nodeType":"VariableDeclaration","scope":8649,"src":"9481:18:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8539,"name":"uint256","nodeType":"ElementaryTypeName","src":"9481:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":8542,"mutability":"mutable","name":"newBalance","nameLocation":"9517:10:20","nodeType":"VariableDeclaration","scope":8649,"src":"9509:18:20","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":8541,"name":"uint256","nodeType":"ElementaryTypeName","src":"9509:7:20","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"9424:109:20"},"returnParameters":{"id":8544,"nodeType":"ParameterList","parameters":[],"src":"9543:0:20"},"scope":8650,"stateMutability":"nonpayable","virtual":false,"visibility":"internal"}],"abstract":false,"baseContracts":[{"baseName":{"id":8125,"name":"ILunarLpFeeManager","nameLocations":["4559:18:20"],"nodeType":"IdentifierPath","referencedDeclaration":22593,"src":"4559:18:20"},"id":8126,"nodeType":"InheritanceSpecifier","src":"4559:18:20"},{"baseName":{"id":8127,"name":"ReentrancyGuard","nameLocations":["4579:15:20"],"nodeType":"IdentifierPath","referencedDeclaration":1245,"src":"4579:15:20"},"id":8128,"nodeType":"InheritanceSpecifier","src":"4579:15:20"}],"canonicalName":"LunarLpFeeManager","contractDependencies":[],"contractKind":"contract","documentation":{"id":8124,"nodeType":"StructuredDocumentation","src":"4458:71:20","text":"@notice Centralized LP fee accounting manager shared by all pools."},"fullyImplemented":true,"linearizedBaseContracts":[8650,1245,22593],"name":"LunarLpFeeManager","nameLocation":"4538:17:20","scope":8651,"usedErrors":[1152,22010,22012,22014,22016],"usedEvents":[8165,8175,8187]}],"license":"MIT"},"id":20}